<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PVCAM: Best Practices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PM_logo_html.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PVCAM
   &#160;<span id="projectnumber">3.10.x</span>
   </div>
   <div id="projectbrief">Programmable Virtual Camera Access Method library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_best_practices.xhtml','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Best Practices </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section contains various guidelines and recommendations that may help application developers to implement common imaging application features or to tackle basic problems that they can face while working with PVCAM or scientific cameras in general.</p>
<p>This section is based on experience from Teledyne Photometrics developers and other developers using PVCAM. The information presented here may not describe the ideal way to resolve a particular problem, but may help other developers to identify bottlenecks and help them implement an efficient and reliable imaging application.</p>
<h1><a class="anchor" id="secBpGeneral"></a>
General Application Recommendations</h1>
<p>With increasing camera sensor resolutions and data throughputs, careful considerations need to be made when designing an imaging application that interfaces with PVCAM. Modern programming languages and frameworks provide developers with great convenience but often with sacrificing performance. Therefore, choosing the right programming environment with good project structure is crucial, especially when performance is important.</p>
<dl class="section note"><dt>Note</dt><dd>Usually, a 'high performance' or a 'high throughput' camera is considered a camera with data throughput over 1GB/s, or a camera with 1000 FPS or more. For example, a Kinetix camera in 8-bit mode may generate up to 5GB of image data <em>per second</em>. Handling such throughput is not trivial and requires careful code structuring and optimizations, not mentioning fast DDR memory and a powerful CPU.</dd></dl>
<p>Since PVCAM is an ANSI-C API, generally any programming language can interface with the library. Teledyne Photometrics provides several higher-level language wrappers to help developers to get started with PVCAM: .NET, Python, LabView adapters to name a few.</p>
<p>These adapters are a great way to quickly start with PVCAM, however since the adapters must interface with higher level languages, some customers may quickly find them limiting in performance or features. Such customers might seek to write their own adapters and applications to address their particular needs.</p>
<p>This section describes several general recommendations to consider when designing a complex imaging application.</p>
<h2><a class="anchor" id="secBpGeneralGui"></a>
Graphical User Interface</h2>
<p>A graphical user interface (GUI) is often required for an imaging application. Multiple GUI frameworks are available for consideration: Microsoft Windows Forms and WPF, Java AWT, Qt, WxWidgets and many more. While any GUI framework will suffice, a special precaution is needed for GUI frameworks that are based on Java, .NET or other languages or runtime environments that require special interfacing with native C libraries.</p>
<p>Interfacing from such languages directly to PVCAM (using .NET P/Invoke or JNI for example) may lead to performance penalties. For example .NET, in most cases, requires all native memory buffers to be 'marshalled' into the managed memory space before they can be safely used in the managed environment. This process involves a memory copy operation that may cause additional delays and increased latencies and will put additional stress on the CPU and memory subsystem.</p>
<p>With such managed environments and when performance is crucial, we recommend writing a custom <em>native</em> C or C++ module that will internally interface with PVCAM, process and manage performance-critical operations such as buffering and data acquisition, and provide simplified access to the higher-level, managed GUI module. For example, an application written in C# .NET may have the GUI implemented using the WPF framework. To avoid frequent memory marshalling, the application can interface with an underlying native 'frame grabber' module that talks to PVCAM and manages all the memory buffers natively. The main .NET application may only request frames to be marshalled at the end of the acquisition, or at a slower rate for purposes of image preview.</p>
<p>Using a <em>native</em> GUI framework may help simplifying memory management. While such frameworks may not always provide similar level of comfort and features as GUI frameworks based on managed environments, applications built with native GUI frameworks can often interface with PVCAM directly, without any intermediate layer. At Teledyne Photometrics, we highly recommend Qt or WxWidgets GUI frameworks.</p>
<h2><a class="anchor" id="secBpGeneralMemoryManagement"></a>
Memory Management</h2>
<p>With PVCAM, all the main frame buffers are allocated and managed by the application (see <a class="el" href="_api_acquisition.xhtml">Image Acquisition Functions</a>). In most cases, the PVCAM device drivers write the image data directly to those buffers, using DMA or other means available with the given camera interface. While memory copying is often inevitable, avoiding frequent copying of frames on the application side is advisable. This recommendation is especially valid when managed application runtime such as .NET or JAVA is used for the main application module. For example, if a .NET application interfaces directly with PVCAM, using P/Invoke approach and a callback acquisition, the callback routine will very likely require a memory marshalling operation for every incoming frame. With the Kinetix example mentioned above, using such approach at 5GB/s or at 1000 FPS is not optimal and may lead to lost frames during the acquisition. A more appropriate approach would be to avoid registering the callback from the .NET directly and instead write a separate native 'frame grabber' module as described in the <a class="el" href="_best_practices.xhtml#secBpGeneralGui">Graphical User Interface</a> section.</p>
<h1><a class="anchor" id="secBpRecommendedFrameAcquisition"></a>
Frame Acquisition and Processing</h1>
<p>As noted in various places across the SDK documentation, the callback acquisition is the recommended method for reliable frame delivery (see <a class="el" href="_polling_vs_callbacks.xhtml">Polling versus Callbacks</a>). This is especially true for fast cameras with high frame rates.</p>
<p>When implementing an application that handles fast frame rates and large amount of data, we recommend the following guidelines:</p>
<ul>
<li>Register an EOF callback with the camera. Registering for additional BOF callbacks is not recommended as BOF notifications no longer provide useful information with fast sCMOS cameras. Additional BOF notifications also increase communication with operating system kernel and may unnecessarily load the system. A callback can only be registered once, after opening the camera. For more information, please refer to <a class="el" href="group__grp__pm__deprecated__functions.xhtml#ga9bc9cc1344932dab4c02e6eb6608bd4d">pl_cam_register_callback_ex</a> and <a class="el" href="_api_acquisition.xhtml">Image Acquisition Functions</a>.</li>
<li>Start a sequence or continuous acquisition (<a class="el" href="group__grp__pm__functions.xhtml#ga3056f74615f53b469c68d4d1c2d9f47d" title="Prepares the camera to perform a readout. ">pl_exp_setup_seq</a>, <a class="el" href="group__grp__pm__functions.xhtml#ga1bce6e5362bf81e6a3110e656fe83ba1" title="Sets circular buffer mode. ">pl_exp_setup_cont</a>). In case of continuous acquisition, choose a reasonably sized circular buffer. The circular buffer acts as a load leveling entity - the larger the circular buffer, the better the application is protected against lost or skipped frames due to temporary system load. The size of the circular buffer is tightly coupled with the callback notifications. If the application holds the callback routine for extended period of time (usually due to a temporary system load), PVCAM queues the notifications up to the size of the circular buffer.</li>
<li>When EOF callback notification is executed by PVCAM, call <a class="el" href="group__grp__pm__functions.xhtml#gae563096dfcd55e57e928aba08944aaec" title="Returns pointer to the most recent frame in circular buffer. ">pl_exp_get_latest_frame_ex()</a> from inside the callback routine to retrieve the frame data pointer. Once retrieved, feel free to process the image data inside the callback, or if lengthy processing is required, <em>copy</em> the frame data to a custom, large processing buffer. In general, callback processing should be faster than the camera frame rate. A temporary slowdowns are balanced by the callback queueing mechanism on the PVCAM side, thus a frame is not immediately lost if one or several callbacks are not executed fast enough. However, if the callback processing is generally slower than the camera frame rate, the frame skipping cannot be avoided.</li>
<li>In order to detect lost or skipped frames, watch the <a class="el" href="pvcam_8h.xhtml#ad473c51b48d07101cab3e2c53c687906">FRAME_INFO</a> <code>FrameNr</code> field. For additional hardware frame counters, use <a class="el" href="_embedded_frame_metadata.xhtml">Embedded Frame Metadata</a> feature.</li>
</ul>
<h1><a class="anchor" id="secBpStreamingToRam"></a>
Streaming to RAM</h1>
<p>Streaming to RAM is the easiest way of acquiring large amounts of data from the camera. For short and limited bursts of frames or for acquisitions with up to 2 or 4 gigabytes of data (depending on the camera interface), a sequence acquisition is recommended (see <a class="el" href="_api_acquisition.xhtml#secApiAcqSequence">Sequence Acquisition</a>).</p>
<p>For long acquisitions exceeding the PVCAM frame buffer limit, the continuous acquisition with additional, custom frame buffer is recommended (see <a class="el" href="_api_acquisition.xhtml#secApiAcqContinuous">Continuous Acquisition</a>).</p>
<p>To accomplish a large RAM acquisition, following steps are recommended:</p><ul>
<li>Prepare a continuous acquisition and obtain the frame size from PVCAM (<a class="el" href="group__grp__pm__functions.xhtml#ga1bce6e5362bf81e6a3110e656fe83ba1" title="Sets circular buffer mode. ">pl_exp_setup_cont</a>).</li>
<li>Allocate a buffer large enough to hold the desired number of frames. This buffer can be as large as free RAM amount, however, limiting the buffer slightly below the free RAM is recommended. For example, a computer with 128GB of RAM may, in a given moment, have about 120GB of free RAM. In this case, it is recommended to allocate a slightly smaller buffer than 120GB to preserve some free RAM capacity for other tasks and to avoid immediate memory paging.</li>
<li>If extremely high data throughput is expected, <em>prefetch</em> the buffer (see <a class="el" href="_best_practices.xhtml#secBpMemoryPrefetch">Memory Buffer Prefetching</a>). Please note that the prefetch operation may take a long time.</li>
<li>Start the continuous acquisition (<a class="el" href="group__grp__pm__functions.xhtml#ga131ec00bebb390c250d3f39756afd35d" title="Begins continuous readout into circular buffer. ">pl_exp_start_cont</a>) with reasonably sized circular buffer using the callback acquisition method. The circular buffer does not have to be extremely large, the only processing inside the callback would be a memory copy operation which usually takes only a couple of milliseconds, depending on the frame size. In general, a circular buffer of 32 or 64 frames should be adequate. However, it is better to match the frame count with actual frame rate to compensate variable CPU load for 1 second, i.e. if the frame rate is 50 fps, a circular buffer of 50 frames is adequate. <a class="el" href="group__grp__pm__parameters.xhtml#gaa59baf1e35daee986f83e5ad96cf7693" title="Retrieves the min, max, current and recommended (default) buffer size in bytes. ">PARAM_FRAME_BUFFER_SIZE</a> can be used to retrieve the recommended buffer size for the current acquisition.</li>
<li>Inside the EOF callback, when frames start arriving, <em>copy</em> the incoming frames to the custom acquisition buffer. Copy additional metadata if needed, for example the <a class="el" href="pvcam_8h.xhtml#ad473c51b48d07101cab3e2c53c687906">FRAME_INFO</a> structure or application-obtained timestamp.</li>
<li>If extremely high data throughput is expected, use parallel memory copy operation (see <a class="el" href="_best_practices.xhtml#secBpParallelMemcpy">Parallel Memory Copy</a>).</li>
</ul>
<h2><a class="anchor" id="secBpMemoryPrefetch"></a>
Memory Buffer Prefetching</h2>
<p>This information is mostly applicable for Windows operating system, but may be relevant for other operating systems as well. The information is also mostly applicable for native applications that are usually built with C or C++ compilers.</p>
<p>When an application allocates a memory buffer, the memory space is only reserved for the application's process. The actual memory is 'committed' to the process only after the process accesses a particular page in the memory buffer for the first time. For example, when a 128GB memory buffer is allocated using the <code>new</code>[] keyword, the allocation itself is very fast - such large memory block is usually allocated within several milliseconds, however, actually writing to the memory buffer may take up to 30 seconds.</p>
<dl class="section note"><dt>Note</dt><dd>Please note that this is usually a case for applications compiled in release mode, applications compiled in debug mode often behave differently and the <code>new</code>[] allocation already takes a very long time due to the system filling the memory block with a debug data pattern.</dd></dl>
<p>For the reasons described above, when copying frames into a newly allocated buffer, it is highly recommended to 'prefetch' the entire memory buffer before staring the acquisition. This is especially very important when working with extreme bandwidths, such as with Kinetix 8-bit mode, where the memory committing on first access causes additional delays.</p>
<p>In order to prepare a RAM buffer for very fast acquisition, at least two options are available:</p><ul>
<li>Use the <code>VirtualAlloc()</code> function instead of the <code>new</code>[] approach.</li>
<li>Implement a simple memory 'prefetch' method as seen in the example below.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Please note the memory prefetching is not needed for PVCAM frame buffers passed to <a class="el" href="group__grp__pm__functions.xhtml#ga3f0f73b953b6c1c4eeff57e6fe165f35" title="Begins exposing, returns immediately. ">pl_exp_start_seq</a> and <a class="el" href="group__grp__pm__functions.xhtml#ga131ec00bebb390c250d3f39756afd35d" title="Begins continuous readout into circular buffer. ">pl_exp_start_cont</a> functions. These buffers are automatically commited and locked in memory by the camera device drivers.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> memory_prefetch(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pBuf, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    SYSTEM_INFO sysInfo;</div><div class="line">    ::GetSystemInfo(&amp;sysInfo);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> pageSize = sysInfo.dwPageSize;</div><div class="line">    <span class="comment">// Write a byte to every page. The assumption is that the OS is</span></div><div class="line">    <span class="comment">// forced to clear/fetch/commit the entire page in memory.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; size; i += pageSize)</div><div class="line">    {</div><div class="line">        pBuf[i] = <span class="charliteral">&#39;x&#39;</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="secBpParallelMemcpy"></a>
Parallel Memory Copy</h2>
<p>Using parallel memory copy instead of the usual <code>memcpy</code> or <code>std::copy</code> may increase the memory copy throughput as much as 3x depending on the amount of memory channels used in the system. For this reason, CPUs with at least 4 memory channels and appropriately configured DRAM modules are generally recommended. There are multiple parallel memory copy approaches available. Simplest approach is to spawn 4 threads and let each thread copy 1/4th of the frame. Since each thread works on a separate part of the memory, no synchronization is generally needed and the approach is very efficient.</p>
<h1><a class="anchor" id="secBpStreamingToDisk"></a>
Streaming to Disk</h1>
<p>Streaming high bandwidth data to disk is one of the difficult tasks when implementing an imaging application. This section describes several limitations and recommendations we have identified when implementing streaming to disk solutions.</p>
<h2><a class="anchor" id="secBpStreamingToDiskTiff"></a>
TIFF Images and TIFF Stacks</h2>
<p>As one of the most commonly used scientific image formats, the TIFF format is usually the first choice when implementing disk streaming solutions. However, depending on what implementation of the TIFF standard is used, several limitations may prevent the application from streaming the data efficiently.</p>
<p>Writing of single TIFF files is usually sufficient for slow frame rates, but it is not recommended for fast frame rates. TIFF stacks are a better option, with a caveat.</p>
<dl class="section note"><dt>Note</dt><dd>As of the Windows version of LibTIFF 4.0.3 we have identified a possible bottleneck with the <code>TIFFWriteDirectory</code> function that is called every time a frame is written to the stack. The execution time of this function progressively increases with number of frames in the stack, slowing down the writing process significantly for stacks with hundreds of frames or greater. For this reason, limiting the stack frame count to 100 frames may be required.</dd></dl>
<h2><a class="anchor" id="secBpStreamingToDiskRaw"></a>
Raw Image Stacks</h2>
<p>For very high frame rates, the overhead of TIFF file format may significantly reduce the disk write throughput. For this reason, writing the frames directly in the format of raw pixel values that PVCAM produces is recommended.</p>
<p>Additionally, the operating system functions for writing data to disk (such as <code>WriteFile</code>) seem to incur a limit when writing buffers sequentially to disk. For example, even with very fast NVMe drives in a RAID array, writing the frame data sequentially using <code>WriteFile</code> is not sufficient and does not fully utilize the NVMe drive capabilities. To fully utilize a NVMe drive capability, a parallel file write may be needed - either by writing multiple image stacks to separate drives in parallel, or by using memory-mapped stacks and writing multiple frames at different locations at the same time.</p>
<p>Also, when selecting an NVMe drive for disk streaming, a careful consideration needs to be made regarding the particular NVMe drive technology. Majority of current NVMe drives use TLC or QLC memory cells and a small cache, their <em>sustained</em> write performance drops significantly when the free cache is depleted - usually after several seconds of sustained write period. For this reason, when selecting an NVMe drive for data streaming, the <em>sequential sustained write speed</em> is the most important factor to consider. For example, at Teledyne Photometrics we currently recommend a Samsung SSD 970 Pro drive that uses MLC cells with no cache. This drive can maintain write speeds of over 2000MB/s over the entire capacity of the drive.</p>
<h1><a class="anchor" id="secBpSummary"></a>
Summary</h1>
<ol type="1">
<li>Use native C/C++ frameworks when implementing high performance imaging applications</li>
<li>When managed frameworks are used, pay special caution to memory management and interfacing</li>
<li>Use callback acquisition with appropriately sized buffers</li>
<li>Process incoming frames directly in the callback or copy frames for additional processing</li>
<li>Use pre-allocated and pre-fetched buffers when copying high-bandwidth data</li>
<li>Avoid frequent memory copying where possible</li>
<li>Use parallel memory copy for large frames and with fast frame rates</li>
<li>Use parallel disk writes and NVMe RAID 0 arrays with extreme frame rates </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
