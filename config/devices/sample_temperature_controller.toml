# config/devices/sample_temperature_controller.toml
# ============================================================================
# SAMPLE: Acme TC-2000 Temperature Controller
# ============================================================================
#
# This is a comprehensive example demonstrating ALL capabilities of the
# GenericSerialDriver TOML configuration format. Use this as a template
# when creating configs for new devices.
#
# The TC-2000 is a fictional device that demonstrates:
# - Serial communication with terminators
# - Multiple capability traits (Readable, Settable, Parameterized)
# - Command templating with parameter interpolation
# - Response parsing with regex patterns
# - Unit conversions with evalexpr formulas
# - Error code mapping with recovery actions
# - Retry configuration with exponential backoff
# - Initialization sequences
# - Rhai scripting for complex operations
# - UI configuration for control panels
#
# Reference: This is a sample file - no real device exists

# ==============================================================================
# SECTION 1: Device Identity
# ==============================================================================
# Defines what the device is and what capabilities it supports.

[device]
name = "Acme TC-2000 Temperature Controller"
description = "Precision temperature controller with PID control and ramping"
manufacturer = "Acme Scientific"
model = "TC-2000"
protocol = "acme_tc2000"              # Unique protocol identifier
category = "sensor"                   # Options: stage, sensor, source, detector, modulator, analyzer, data_acquisition, other

# Capability traits this device implements (determines which trait methods are available)
capabilities = ["Readable", "Settable", "Parameterized"]

# ==============================================================================
# SECTION 2: Connection Settings
# ==============================================================================
# How to communicate with the device over serial port.

[connection]
type = "serial"                       # Connection type: serial, rs485, tcp, udp
baud_rate = 9600                      # Serial baud rate (300-921600)
data_bits = 8                         # Data bits (5-8)
parity = "none"                       # Parity: none, odd, even
stop_bits = 1                         # Stop bits: 1 or 2
flow_control = "none"                 # Flow control: none, software, hardware
timeout_ms = 2000                     # Read/write timeout in milliseconds

# Command/response terminators
terminator_tx = "\r\n"                # Sent after each command (CR+LF)
terminator_rx = "\r\n"                # Expected in responses

# Optional: specify port path (usually set at runtime)
# port_path = "/dev/ttyUSB0"

# ==============================================================================
# SECTION 3: Retry Configuration (Default)
# ==============================================================================
# Default retry behavior for all commands (can be overridden per-command).

[default_retry]
max_retries = 3                       # Maximum retry attempts (0-10)
initial_delay_ms = 100                # Delay before first retry
max_delay_ms = 2000                   # Maximum delay between retries
backoff_multiplier = 2.0              # Exponential backoff factor

# Error codes that should trigger retry (if empty, retries on any error)
retry_on_errors = ["ERR_BUSY", "ERR_COMM"]

# Error codes that should NEVER trigger retry (takes precedence)
no_retry_on_errors = ["ERR_FATAL", "ERR_OVERTEMP"]

# ==============================================================================
# SECTION 4: Device Parameters
# ==============================================================================
# Runtime parameters that can be read/written and used in conversions.
# These are stored in the driver and can be referenced in formulas.

[parameters.setpoint_celsius]
type = "float"
default = 25.0
range = [-40.0, 200.0]                # Valid range [min, max]
unit = "°C"
description = "Target temperature setpoint"

[parameters.actual_temp_celsius]
type = "float"
default = 25.0
unit = "°C"
description = "Current measured temperature"
read_only = true                      # Cannot be set directly

[parameters.heater_power_percent]
type = "float"
default = 0.0
range = [0.0, 100.0]
unit = "%"
description = "Current heater output power"
read_only = true

[parameters.pid_p]
type = "float"
default = 10.0
range = [0.0, 1000.0]
description = "PID proportional gain"

[parameters.pid_i]
type = "float"
default = 0.5
range = [0.0, 100.0]
description = "PID integral gain"

[parameters.pid_d]
type = "float"
default = 2.0
range = [0.0, 100.0]
description = "PID derivative gain"

[parameters.ramp_rate_c_per_min]
type = "float"
default = 5.0
range = [0.1, 50.0]
unit = "°C/min"
description = "Temperature ramp rate"

[parameters.control_mode]
type = "string"
default = "PID"
choices = ["OFF", "PID", "MANUAL", "RAMP"]
description = "Temperature control mode"

[parameters.alarm_high_celsius]
type = "float"
default = 150.0
range = [-40.0, 250.0]
unit = "°C"
description = "High temperature alarm threshold"

[parameters.alarm_low_celsius]
type = "float"
default = 0.0
range = [-50.0, 200.0]
unit = "°C"
description = "Low temperature alarm threshold"

# ==============================================================================
# SECTION 5: Command Definitions
# ==============================================================================
# Define all commands the device supports.
# Template syntax: ${param_name} or ${param_name:format}
# Formats: 08X (8-char hex), 04d (4-digit decimal), etc.

# --- Temperature Query/Set Commands ---

[commands.get_temperature]
template = "TEMP?"
description = "Query current temperature"
response = "temperature"              # Name of response definition to use

[commands.get_setpoint]
template = "SETP?"
description = "Query temperature setpoint"
response = "setpoint"

[commands.set_setpoint]
template = "SETP ${value}"
description = "Set temperature setpoint (°C)"
parameters = { value = "float" }
expects_response = false              # No response expected

# Per-command retry override
[commands.set_setpoint.retry]
max_retries = 2
initial_delay_ms = 200

# --- PID Commands ---

[commands.get_pid]
template = "PID?"
description = "Query PID parameters"
response = "pid_values"

[commands.set_pid]
template = "PID ${p},${i},${d}"
description = "Set PID parameters (P, I, D)"
parameters = { p = "float", i = "float", d = "float" }
expects_response = false

# --- Control Mode Commands ---

[commands.get_mode]
template = "MODE?"
description = "Query control mode"
response = "mode"

[commands.set_mode]
template = "MODE ${mode}"
description = "Set control mode"
parameters = { mode = "string" }
expects_response = false

# --- Status Commands ---

[commands.get_status]
template = "STAT?"
description = "Query device status (bit flags)"
response = "status"

[commands.get_heater_power]
template = "HTR?"
description = "Query heater output power"
response = "heater_power"

# --- Alarm Commands ---

[commands.get_alarms]
template = "ALARM?"
description = "Query alarm settings"
response = "alarms"

[commands.set_alarm_high]
template = "ALMHI ${temp}"
description = "Set high temperature alarm"
parameters = { temp = "float" }
expects_response = false

[commands.set_alarm_low]
template = "ALMLO ${temp}"
description = "Set low temperature alarm"
parameters = { temp = "float" }
expects_response = false

[commands.clear_alarms]
template = "ALMCLR"
description = "Clear active alarms"
expects_response = false

# --- Ramp Commands ---

[commands.set_ramp_rate]
template = "RAMP ${rate}"
description = "Set ramp rate (°C/min)"
parameters = { rate = "float" }
expects_response = false

[commands.start_ramp]
template = "RAMP:START ${target}"
description = "Start ramping to target temperature"
parameters = { target = "float" }
expects_response = false
timeout_ms = 5000                     # Per-command timeout override

[commands.stop_ramp]
template = "RAMP:STOP"
description = "Stop temperature ramp"
expects_response = false

# --- Utility Commands ---

[commands.identify]
template = "*IDN?"
description = "Query device identity"
response = "identity"

[commands.reset]
template = "*RST"
description = "Reset device to defaults"
expects_response = false
delay_ms = 2000                       # Wait after command

# ==============================================================================
# SECTION 6: Response Definitions
# ==============================================================================
# Define how to parse responses using regex with named capture groups.
# Field types: string, int, uint, float, bool, hex_u8, hex_u16, hex_u32, hex_i32

# Temperature response: "TEMP 25.50"
[responses.temperature]
pattern = "^TEMP\\s+(?P<value>[+-]?\\d+\\.?\\d*)$"

[responses.temperature.fields.value]
type = "float"
unit = "°C"

# Setpoint response: "SETP 30.00"
[responses.setpoint]
pattern = "^SETP\\s+(?P<value>[+-]?\\d+\\.?\\d*)$"

[responses.setpoint.fields.value]
type = "float"

# PID response: "PID 10.0,0.5,2.0"
[responses.pid_values]
pattern = "^PID\\s+(?P<p>\\d+\\.?\\d*),(?P<i>\\d+\\.?\\d*),(?P<d>\\d+\\.?\\d*)$"

[responses.pid_values.fields.p]
type = "float"

[responses.pid_values.fields.i]
type = "float"

[responses.pid_values.fields.d]
type = "float"

# Mode response: "MODE PID"
[responses.mode]
pattern = "^MODE\\s+(?P<mode>\\w+)$"

[responses.mode.fields.mode]
type = "string"

# Status response: "STAT 0x05" (bit flags as hex)
[responses.status]
pattern = "^STAT\\s+0x(?P<flags>[0-9A-Fa-f]+)$"

[responses.status.fields.flags]
type = "hex_u8"

# Heater power response: "HTR 45.2"
[responses.heater_power]
pattern = "^HTR\\s+(?P<power>\\d+\\.?\\d*)$"

[responses.heater_power.fields.power]
type = "float"

# Alarm response: "ALARM HI:150.0 LO:0.0"
[responses.alarms]
pattern = "^ALARM\\s+HI:(?P<high>[+-]?\\d+\\.?\\d*)\\s+LO:(?P<low>[+-]?\\d+\\.?\\d*)$"

[responses.alarms.fields.high]
type = "float"

[responses.alarms.fields.low]
type = "float"

# Identity response: "ACME,TC-2000,SN12345,v1.2"
[responses.identity]
pattern = "^(?P<manufacturer>\\w+),(?P<model>[\\w-]+),(?P<serial>\\w+),v(?P<version>[\\d.]+)$"

[responses.identity.fields.manufacturer]
type = "string"

[responses.identity.fields.model]
type = "string"

[responses.identity.fields.serial]
type = "string"

[responses.identity.fields.version]
type = "string"

# ==============================================================================
# SECTION 7: Unit Conversions
# ==============================================================================
# Define conversion formulas using evalexpr syntax.
# Available: +, -, *, /, %, round(), floor(), ceil(), abs()
# Can reference any parameter by name.

[conversions.celsius_to_fahrenheit]
formula = "celsius * 9.0 / 5.0 + 32.0"
description = "Convert Celsius to Fahrenheit"

[conversions.fahrenheit_to_celsius]
formula = "(fahrenheit - 32.0) * 5.0 / 9.0"
description = "Convert Fahrenheit to Celsius"

[conversions.celsius_to_kelvin]
formula = "celsius + 273.15"
description = "Convert Celsius to Kelvin"

[conversions.kelvin_to_celsius]
formula = "kelvin - 273.15"
description = "Convert Kelvin to Celsius"

# ==============================================================================
# SECTION 8: Error Code Mapping
# ==============================================================================
# Define device-specific error codes with severity and recovery actions.

[error_codes."ERR_NONE"]
name = "OK"
description = "No error"
recoverable = true
severity = "info"

[error_codes."ERR_COMM"]
name = "CommunicationError"
description = "Communication timeout or checksum error"
recoverable = true
severity = "warning"

[error_codes."ERR_BUSY"]
name = "DeviceBusy"
description = "Device is busy processing previous command"
recoverable = true
severity = "info"

[error_codes."ERR_BUSY".recovery_action]
auto_recover = true
delay_ms = 500

[error_codes."ERR_RANGE"]
name = "OutOfRange"
description = "Parameter value out of valid range"
recoverable = true
severity = "error"

[error_codes."ERR_OVERTEMP"]
name = "OverTemperature"
description = "Temperature exceeded safety limit"
recoverable = false
severity = "critical"

[error_codes."ERR_OVERTEMP".recovery_action]
auto_recover = false
manual_instructions = "Allow device to cool down. Check for thermal runaway."

[error_codes."ERR_SENSOR"]
name = "SensorFault"
description = "Temperature sensor fault"
recoverable = false
severity = "critical"

[error_codes."ERR_SENSOR".recovery_action]
auto_recover = false
manual_instructions = "Check sensor connections. May require service."

[error_codes."ERR_FATAL"]
name = "FatalError"
description = "Unrecoverable hardware error"
recoverable = false
severity = "fatal"

[error_codes."ERR_FATAL".recovery_action]
auto_recover = false
command = "reset"
manual_instructions = "Power cycle the device. Contact support if issue persists."

# ==============================================================================
# SECTION 9: Validation Rules
# ==============================================================================
# Additional validation constraints for parameters.

[validation.setpoint_celsius]
range = [-40.0, 200.0]
unit = "°C"
error_message = "Setpoint must be between -40°C and 200°C"

[validation.ramp_rate_c_per_min]
range = [0.1, 50.0]
unit = "°C/min"
error_message = "Ramp rate must be between 0.1 and 50 °C/min"

# ==============================================================================
# SECTION 10: Trait Mapping
# ==============================================================================
# Maps capability trait methods to device commands.

# --- Readable trait: read() returns current temperature ---
[trait_mapping.Readable.read]
command = "get_temperature"
output_field = "value"

# --- Settable trait (if implemented) ---
# [trait_mapping.Settable.set]
# command = "set_setpoint"
# input_param = "value"
# from_param = "setpoint"

# ==============================================================================
# SECTION 11: Initialization Sequence
# ==============================================================================
# Commands to run when connecting to verify device identity and state.

[[init_sequence]]
command = "identify"
description = "Query device identity to verify correct device"
required = true
expect = "ACME"                       # Response must contain this string

[[init_sequence]]
command = "get_status"
description = "Check device status"
required = true
delay_ms = 100

[[init_sequence]]
command = "get_temperature"
description = "Get initial temperature reading"
required = false

[[init_sequence]]
command = "get_setpoint"
description = "Get current setpoint"
required = false

# ==============================================================================
# SECTION 12: Rhai Scripts (Optional)
# ==============================================================================
# For complex operations that can't be expressed declaratively.
# Scripts have access to: input, address, and all parameters.
# Available functions: driver.command_name(), driver.wait_ms(ms)

[scripts.ramp_to_temperature]
description = "Ramp to target temperature and wait until stable"
timeout_ms = 300000                   # 5 minutes
inputs = ["target"]
returns = "float"
script = """
    // Set the ramp target
    let target = input;
    
    // Configure ramp rate (use parameter or default)
    let rate = if ramp_rate_c_per_min > 0.0 {
        ramp_rate_c_per_min
    } else {
        5.0
    };
    
    // Start the ramp
    driver.set_ramp_rate(rate);
    driver.start_ramp(target);
    
    // Poll until temperature is stable
    let stable_count = 0;
    let tolerance = 0.5;  // °C
    
    loop {
        driver.wait_ms(1000);
        let temp = driver.get_temperature();
        
        if abs(temp - target) < tolerance {
            stable_count += 1;
            if stable_count >= 3 {
                break;  // Stable for 3 consecutive readings
            }
        } else {
            stable_count = 0;
        }
    }
    
    // Return final temperature
    driver.get_temperature()
"""

[scripts.autotune_pid]
description = "Run PID autotuning sequence"
timeout_ms = 600000                   # 10 minutes
inputs = []
returns = "string"
script = """
    // Save current setpoint
    let original_setpoint = driver.get_setpoint();
    
    // Put in manual mode for autotuning
    driver.set_mode("MANUAL");
    driver.wait_ms(500);
    
    // Simple relay autotuning (simplified example)
    let cycles = 0;
    let oscillations = [];
    
    while cycles < 5 {
        // Toggle heater and measure response
        // (simplified - real implementation would be more complex)
        driver.wait_ms(5000);
        let temp = driver.get_temperature();
        oscillations.push(temp);
        cycles += 1;
    }
    
    // Calculate new PID values (simplified)
    let amplitude = 5.0;  // Would calculate from oscillations
    let period = 60.0;    // Would calculate from oscillations
    
    let ku = 4.0 / (3.14159 * amplitude);
    let tu = period;
    
    // Ziegler-Nichols tuning
    let new_p = 0.6 * ku;
    let new_i = 2.0 * new_p / tu;
    let new_d = new_p * tu / 8.0;
    
    // Apply new PID values
    driver.set_pid(new_p, new_i, new_d);
    
    // Restore PID mode
    driver.set_mode("PID");
    driver.set_setpoint(original_setpoint);
    
    // Return result
    "Autotune complete: P=" + new_p + ", I=" + new_i + ", D=" + new_d
"""

# ==============================================================================
# SECTION 13: UI Configuration
# ==============================================================================
# Defines how the device appears in the GUI control panel.

[ui]
icon = "thermometer"
color = "#FF6B35"                     # Orange theme color

[ui.control_panel]
layout = "vertical"
show_header = true
collapsible = true

# Temperature display section
[[ui.control_panel.sections]]
type = "sensor"
label = "Temperature"
precision = 2
unit = "°C"
show_trend = true
refresh_ms = 1000

# Setpoint control section
[[ui.control_panel.sections]]
type = "parameter"
label = "Setpoint"
parameter = "setpoint_celsius"
widget = "spinner"

# Visual separator
[[ui.control_panel.sections]]
type = "separator"
visible = true

# Preset temperature buttons
[[ui.control_panel.sections]]
type = "preset_buttons"
label = "Quick Setpoints"
vertical = false
presets = [
    { label = "Room", value = 25.0 },
    { label = "37°C", value = 37.0 },
    { label = "50°C", value = 50.0 },
    { label = "100°C", value = 100.0 },
]

# Control mode selector
[[ui.control_panel.sections]]
type = "parameter"
label = "Mode"
parameter = "control_mode"
widget = "dropdown"

# PID parameters (collapsible section would be nice)
[[ui.control_panel.sections]]
type = "status_display"
label = "PID Settings"
parameters = ["pid_p", "pid_i", "pid_d"]
compact = true

# Heater power indicator
[[ui.control_panel.sections]]
type = "parameter"
label = "Heater Output"
parameter = "heater_power_percent"
widget = "slider"
read_only = true

# Custom action buttons
[[ui.control_panel.sections]]
type = "custom_action"
label = "Run Autotune"
command = "autotune_pid"
style = "primary"
confirm = "This will take ~10 minutes. Continue?"

[[ui.control_panel.sections]]
type = "separator"
visible = true

[[ui.control_panel.sections]]
type = "custom_action"
label = "Clear Alarms"
command = "clear_alarms"
style = "secondary"

# Status display configuration (for device tree/summary)
[ui.status_display]
summary_params = ["actual_temp_celsius", "setpoint_celsius"]
summary_format = "${actual_temp_celsius}°C → ${setpoint_celsius}°C"
show_connection = true
