# Example Scriptable Capability Plugin
#
# This example showcases the SCRIPTABLE capability type, which allows embedding
# Rhai scripts directly in the YAML configuration for complex operations that
# can't be expressed as simple command/response patterns.
#
# Scriptable capabilities are ideal for:
# - Multi-step procedures with conditional logic
# - State machines and sequences
# - Safety interlocks and validation
# - Complex initialization/shutdown procedures
# - Automated calibration routines
#
# This example models a tunable laser system with wavelength control and
# complex startup/shutdown procedures.

metadata:
  id: "example-scriptable-laser"
  name: "Example Scriptable Tunable Laser"
  version: "1.0.0"
  driver_type: "serial_scpi"

protocol:
  baud_rate: 19200
  termination: "\n"
  command_delay_ms: 100         # Laser commands need settling time
  timeout_ms: 5000              # Some operations are slow

on_connect:
  - cmd: "*IDN?"
    wait_ms: 100
  - cmd: "*CLS"                 # Clear status
  - cmd: "SYST:REM"             # Remote mode
  # Note: We don't turn on laser automatically - use script for that

on_disconnect:
  - cmd: "SYST:LOC"

error_patterns:
  - "ERROR"
  - "INTERLOCK"
  - "OVERTEMP"
  - "FAULT"

capabilities:

  # Basic readable capabilities
  readable:
    - name: "wavelength"
      command: "WAV?"
      pattern: "{val:f}"
      unit: "nm"
      mock:
        default: 780.0
        jitter: 0.1

    - name: "power"
      command: "POW?"
      pattern: "{val:f}"
      unit: "mW"
      mock:
        default: 0.0            # Start with laser off
        jitter: 0.0

    - name: "temperature"
      command: "TEMP:CRYS?"     # Crystal temperature
      pattern: "{val:f}"
      unit: "C"
      mock:
        default: 25.0
        jitter: 0.5

    - name: "tec_current"
      command: "TEC:CURR?"      # Thermoelectric cooler current
      pattern: "{val:f}"
      unit: "A"
      mock:
        default: 0.5
        jitter: 0.05

    - name: "diode_current"
      command: "DIOD:CURR?"
      pattern: "{val:f}"
      unit: "mA"
      mock:
        default: 0.0
        jitter: 0.0

    - name: "cavity_lock_error"
      command: "CAV:ERR?"       # Cavity lock error signal
      pattern: "{val:f}"
      unit: "mV"
      mock:
        default: 0.0
        jitter: 0.1

  # Settable parameters
  settable:
    - name: "wavelength_setpoint"
      set_cmd: "WAV {val}"
      get_cmd: "WAV:SET?"
      pattern: "{val:f}"
      value_type: float
      unit: "nm"
      min: 700.0
      max: 1000.0
      mock:
        default: 780.0
        jitter: 0.0

    - name: "power_setpoint"
      set_cmd: "POW {val}"
      get_cmd: "POW:SET?"
      pattern: "{val:f}"
      value_type: float
      unit: "mW"
      min: 0.0
      max: 100.0
      mock:
        default: 10.0
        jitter: 0.0

    - name: "temperature_setpoint"
      set_cmd: "TEMP:SET {val}"
      get_cmd: "TEMP:SET?"
      pattern: "{val:f}"
      value_type: float
      unit: "C"
      min: 20.0
      max: 30.0
      mock:
        default: 25.0
        jitter: 0.0

    - name: "tune_speed"
      set_cmd: "WAV:SPEED {val}"
      get_cmd: "WAV:SPEED?"
      pattern: "{val}"
      value_type: enum
      options: ["SLOW", "MEDIUM", "FAST"]

  # Binary switches
  switchable:
    - name: "emission"
      on_cmd: "EMIS ON"
      off_cmd: "EMIS OFF"
      status_cmd: "EMIS?"
      pattern: "{val}"
      mock:
        default: 0.0
        jitter: 0.0

    - name: "tec_enabled"
      on_cmd: "TEC ON"
      off_cmd: "TEC OFF"
      status_cmd: "TEC?"
      pattern: "{val}"
      mock:
        default: 0.0
        jitter: 0.0

    - name: "cavity_lock"
      on_cmd: "CAV:LOCK ON"
      off_cmd: "CAV:LOCK OFF"
      status_cmd: "CAV:LOCK?"
      pattern: "{val}"
      mock:
        default: 0.0
        jitter: 0.0

    - name: "shutter"
      on_cmd: "SHUT OPEN"
      off_cmd: "SHUT CLOSE"
      status_cmd: "SHUT?"
      pattern: "{val}"
      mock:
        default: 0.0
        jitter: 0.0

  # Simple actions
  actionable:
    - name: "optimize_cavity"
      cmd: "CAV:OPT"
      wait_ms: 3000

    - name: "measure_power"
      cmd: "POW:MEAS"
      wait_ms: 500

  # SCRIPTABLE capabilities - the main feature of this example
  scriptable:

    # Complex startup sequence with safety checks
    - name: "safe_startup"
      description: "Safely start up the laser with full safety checks and warm-up"
      timeout_ms: 60000         # 60 seconds max
      script: |
        // Check if laser is already running
        let current_power = driver.read("power");
        if current_power > 1.0 {
          print("WARNING: Laser already emitting " + current_power + " mW");
          return "Aborted - laser already on";
        }

        // Check temperature is in safe range
        let temp = driver.read("temperature");
        if temp < 20.0 || temp > 30.0 {
          print("ERROR: Temperature out of range: " + temp + "C");
          return "Aborted - unsafe temperature";
        }

        print("Starting laser initialization sequence...");

        // Step 1: Enable TEC and wait for temperature stabilization
        print("Step 1: Enabling TEC...");
        driver.switch_on("tec_enabled");
        sleep(2.0);

        // Wait for temperature to stabilize (max 30 seconds)
        print("Step 2: Waiting for temperature stabilization...");
        for i in 0..30 {
          let current_temp = driver.read("temperature");
          let setpoint = driver.get("temperature_setpoint");
          let error = abs(current_temp - setpoint);

          if error < 0.1 {
            print("Temperature stabilized at " + current_temp + "C");
            break;
          }

          if i == 29 {
            driver.switch_off("tec_enabled");
            return "ERROR: Temperature failed to stabilize";
          }

          sleep(1.0);
        }

        // Step 3: Enable diode emission at low power
        print("Step 3: Enabling emission at low power...");
        driver.set("power_setpoint", 5.0);
        sleep(0.5);
        driver.switch_on("emission");
        sleep(2.0);

        // Verify emission
        let power = driver.read("power");
        if power < 1.0 {
          driver.switch_off("emission");
          driver.switch_off("tec_enabled");
          return "ERROR: Emission failed to start";
        }

        // Step 4: Lock cavity (if available)
        print("Step 4: Attempting cavity lock...");
        driver.switch_on("cavity_lock");
        sleep(1.0);

        // Check if lock acquired
        let lock_error = driver.read("cavity_lock_error");
        if abs(lock_error) < 10.0 {
          print("Cavity lock acquired (error: " + lock_error + " mV)");
        } else {
          print("WARNING: Cavity lock error high: " + lock_error + " mV");
          print("Continuing without lock...");
        }

        // Step 5: Ramp to target power
        print("Step 5: Ramping to operating power...");
        let target_power = driver.get("power_setpoint");
        let steps = 10;
        let step_size = target_power / steps;

        for i in 1..=steps {
          let power_level = step_size * i;
          driver.set("power_setpoint", power_level);
          sleep(0.5);
        }

        print("Startup complete! Laser at " + driver.read("power") + " mW");
        return "SUCCESS";

    # Complex shutdown sequence
    - name: "safe_shutdown"
      description: "Gracefully shut down laser with proper sequencing"
      timeout_ms: 30000
      script: |
        print("Starting laser shutdown sequence...");

        // Check if already off
        let power = driver.read("power");
        if power < 0.1 {
          print("Laser already off");
          return "Already off";
        }

        // Step 1: Close shutter for safety
        print("Step 1: Closing shutter...");
        driver.switch_off("shutter");
        sleep(0.5);

        // Step 2: Ramp down power gradually
        print("Step 2: Ramping down power...");
        let current_power = driver.get("power_setpoint");
        let steps = 5;

        for i in 0..steps {
          let remaining = steps - i;
          let power_level = current_power * remaining / steps;
          driver.set("power_setpoint", power_level);
          print("Power: " + power_level + " mW");
          sleep(1.0);
        }

        // Step 3: Disable emission
        print("Step 3: Disabling emission...");
        driver.switch_off("emission");
        sleep(1.0);

        // Step 4: Disable cavity lock
        print("Step 4: Disabling cavity lock...");
        driver.switch_off("cavity_lock");
        sleep(0.5);

        // Step 5: Disable TEC (allow cooldown first)
        print("Step 5: TEC cooldown...");
        sleep(3.0);
        driver.switch_off("tec_enabled");

        print("Shutdown complete");
        return "SUCCESS";

    # Wavelength sweep with data collection
    - name: "wavelength_sweep"
      description: "Sweep wavelength from current to target while monitoring power"
      timeout_ms: 120000        # 2 minutes
      script: |
        // This script demonstrates data collection during a sweep
        // In a real implementation, you'd log data to a file or buffer

        print("Starting wavelength sweep...");

        // Get current and target wavelength
        let start_wl = driver.read("wavelength");
        let end_wl = driver.get("wavelength_setpoint");

        if abs(end_wl - start_wl) < 1.0 {
          return "ERROR: Target too close to current wavelength";
        }

        print("Sweeping from " + start_wl + " nm to " + end_wl + " nm");

        // Set slow tuning for stability
        let old_speed = driver.get("tune_speed");
        driver.set("tune_speed", "SLOW");

        // Calculate sweep parameters
        let num_steps = 20;
        let step_size = (end_wl - start_wl) / num_steps;

        // Perform sweep
        for i in 0..=num_steps {
          let target_wl = start_wl + step_size * i;
          driver.set("wavelength_setpoint", target_wl);
          sleep(2.0);  // Wait for wavelength to settle

          // Read and "log" data (in real use, save to file)
          let actual_wl = driver.read("wavelength");
          let power = driver.read("power");
          print("Step " + i + ": Î»=" + actual_wl + " nm, P=" + power + " mW");

          // Check stability
          if abs(actual_wl - target_wl) > 1.0 {
            print("WARNING: Wavelength error exceeds 1 nm");
          }
        }

        // Restore original tuning speed
        driver.set("tune_speed", old_speed);

        print("Sweep complete");
        return "SUCCESS";

    # Automated cavity optimization
    - name: "cavity_optimize"
      description: "Optimize cavity alignment for maximum power"
      timeout_ms: 45000
      script: |
        print("Starting cavity optimization...");

        // Ensure emission is on
        let power = driver.read("power");
        if power < 0.1 {
          return "ERROR: Laser emission must be enabled first";
        }

        // Record starting power
        let start_power = power;
        print("Initial power: " + start_power + " mW");

        // Try different optimization strategies
        print("Attempting automatic optimization...");
        driver.action("optimize_cavity");
        sleep(3.0);

        // Check result
        let optimized_power = driver.read("power");
        let improvement = optimized_power - start_power;
        let percent = (improvement / start_power) * 100.0;

        if improvement > 0.0 {
          print("Optimization improved power by " + improvement + " mW (" + percent + "%)");
          return "SUCCESS: +" + percent + "%";
        } else {
          print("Optimization did not improve power");
          return "No improvement";
        }

    # Emergency shutdown with minimal delays
    - name: "emergency_stop"
      description: "Immediate shutdown without gradual ramp-down"
      timeout_ms: 5000
      script: |
        print("!!! EMERGENCY STOP !!!");

        // Close shutter immediately
        driver.switch_off("shutter");

        // Disable emission
        driver.switch_off("emission");

        // Disable cavity lock
        driver.switch_off("cavity_lock");

        // Set power to zero
        driver.set("power_setpoint", 0.0);

        print("Emergency stop complete - laser disabled");
        return "STOPPED";

  # Static metadata
  loggable:
    - name: "device_id"
      cmd: "*IDN?"
      pattern: "{val}"

    - name: "serial_number"
      cmd: "SYST:SER?"
      pattern: "{val}"

# UI layout with script buttons
ui_layout:
  - type: "group"
    label: "Wavelength Control"
    children:
      - type: "readout"
        source: "wavelength"
        label: "Current Wavelength"

      - type: "slider"
        target: "wavelength_setpoint"
        label: "Target Wavelength (nm)"

      - type: "dropdown"
        target: "tune_speed"
        label: "Tuning Speed"

  - type: "group"
    label: "Power Control"
    children:
      - type: "readout"
        source: "power"
        label: "Output Power"

      - type: "slider"
        target: "power_setpoint"
        label: "Power Setpoint (mW)"

      - type: "toggle"
        target: "emission"
        label: "Emission Enable"

      - type: "toggle"
        target: "shutter"
        label: "Shutter Open"

  - type: "group"
    label: "Temperature & TEC"
    children:
      - type: "readout"
        source: "temperature"
        label: "Crystal Temperature"

      - type: "slider"
        target: "temperature_setpoint"
        label: "Temperature Setpoint"

      - type: "toggle"
        target: "tec_enabled"
        label: "TEC Enabled"

      - type: "readout"
        source: "tec_current"
        label: "TEC Current"

  - type: "group"
    label: "Cavity Lock"
    children:
      - type: "toggle"
        target: "cavity_lock"
        label: "Lock Enabled"

      - type: "readout"
        source: "cavity_lock_error"
        label: "Lock Error Signal"

      - type: "button"
        action: "optimize_cavity"
        label: "Quick Optimize"

  - type: "group"
    label: "Automated Procedures"
    children:
      # Note: Scriptable capabilities don't have direct UI bindings yet
      # These would need to be exposed through the driver API
      # For now, document them here as planned future features

      - type: "button"
        action: "measure_power"
        label: "Measure Power"

    # Future: Add script execution buttons
    # - Script: safe_startup
    # - Script: safe_shutdown
    # - Script: wavelength_sweep
    # - Script: cavity_optimize
    # - Script: emergency_stop

  - type: "group"
    label: "Diagnostics"
    children:
      - type: "readout"
        source: "diode_current"
        label: "Diode Current"
