---
phase: 01-form-based-scan-builder
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/daq-egui/src/panels/scan_builder.rs
autonomous: true

must_haves:
  truths:
    - "User can click Start and experiment begins executing"
    - "User can see live 1D plot updating as data arrives"
    - "User can click Abort and experiment stops immediately"
    - "Progress bar shows current point and estimated time remaining"
  artifacts:
    - path: "crates/daq-egui/src/panels/scan_builder.rs"
      provides: "Start/Abort execution, document streaming, live 1D plotting"
      contains: "stream_documents"
  key_links:
    - from: "crates/daq-egui/src/panels/scan_builder.rs"
      to: "client.queue_plan()"
      via: "PendingAction::StartScan async task"
      pattern: "queue_plan"
    - from: "crates/daq-egui/src/panels/scan_builder.rs"
      to: "client.stream_documents()"
      via: "document subscription task"
      pattern: "stream_documents"
    - from: "crates/daq-egui/src/panels/scan_builder.rs"
      to: "egui_plot::Plot"
      via: "render_live_plot method"
      pattern: "Plot::new"
---

<objective>
Add execution controls and live 1D plotting to the ScanBuilderPanel.

Purpose: Enable scientists to start scans from the form, watch data arrive in real-time on a live plot, and abort execution immediately when needed.

Output: Start/Abort buttons, progress bar with ETA, document stream subscription, and live-updating line plot for 1D scans.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-form-based-scan-builder/01-CONTEXT.md
@.planning/phases/01-form-based-scan-builder/01-RESEARCH.md

# Reference implementations for document streaming and plotting:
@crates/daq-egui/src/panels/document_viewer.rs
@crates/daq-egui/src/panels/signal_plotter.rs
@crates/daq-egui/src/panels/plan_runner.rs

# Prior plan context:
@.planning/phases/01-form-based-scan-builder/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execution state and Start/Abort controls</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**Add execution state to ScanBuilderPanel:**
```rust
// Execution state
execution_state: ExecutionState,
current_run_uid: Option<String>,
start_time: Option<Instant>,

// Progress tracking
total_points: u32,
current_point: u32,

// Document streaming
document_rx: Option<mpsc::Receiver<Result<Document, String>>>,
subscription_task: Option<JoinHandle<()>>,

enum ExecutionState {
    Idle,
    Running,
    Aborting,
}
```

**Extend PendingAction enum:**
```rust
enum PendingAction {
    RefreshDevices,
    StartScan {
        plan_type: String,
        parameters: HashMap<String, String>,
        device_mapping: HashMap<String, String>,
    },
    AbortScan,
}

enum ActionResult {
    DevicesLoaded(Result<Vec<DeviceInfo>, String>),
    ScanStarted { run_uid: String, error: Option<String> },
    ScanAborted { success: bool, error: Option<String> },
}
```

**Start button logic:**
1. Validate form (call `validate_form()`, return early if errors)
2. Build plan parameters from form fields:
   - 1D: `{"start_position": start_1d, "stop_position": stop_1d, "num_points": points_1d}`
   - Device mapping: `{"motor": selected_actuator, "detector": selected_detectors[0]}`
3. Set `pending_action = Some(PendingAction::StartScan { ... })`
4. In `execute_action()`, spawn async task that:
   - Calls `client.queue_plan("line_scan", parameters, device_mapping, metadata)`
   - On success, calls `client.start_engine()`
   - Sends result back via channel

**Abort button logic:**
1. Set `pending_action = Some(PendingAction::AbortScan)`
2. In `execute_action()`, spawn async task that calls `client.abort_plan()`
   - Note: `abort_plan()` aborts the currently running plan - no plan_id required.
   - The RunEngine tracks the active plan internally.
3. Also abort the document subscription task if running

**UI Layout (at bottom of form):**
```rust
ui.separator();
ui.horizontal(|ui| {
    match self.execution_state {
        ExecutionState::Idle => {
            let can_start = self.validation_errors.is_empty()
                && self.selected_actuator.is_some()
                && !self.selected_detectors.is_empty();

            if ui.add_enabled(can_start, egui::Button::new("Start Scan")).clicked() {
                self.pending_action = Some(PendingAction::StartScan { ... });
            }
        }
        ExecutionState::Running => {
            if ui.button("Abort").clicked() {
                self.pending_action = Some(PendingAction::AbortScan);
            }
        }
        ExecutionState::Aborting => {
            ui.add_enabled(false, egui::Button::new("Aborting..."));
        }
    }
});
```
  </action>
  <verify>
- `cargo check -p daq-egui` passes
- Start button disabled when form invalid
- Abort button appears when running
- State transitions correctly on button clicks
  </verify>
  <done>Start/Abort buttons working with correct state transitions and form validation gating</done>
</task>

<task type="auto">
  <name>Task 2: Add document streaming and progress tracking</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**Start document subscription after scan starts:**
In the `ScanStarted` action result handler:
```rust
ActionResult::ScanStarted { run_uid, error: None } => {
    self.execution_state = ExecutionState::Running;
    self.current_run_uid = Some(run_uid.clone());
    self.start_time = Some(Instant::now());
    self.current_point = 0;
    // Parse total_points from form
    self.total_points = self.points_1d.parse().unwrap_or(0);

    // Start document subscription
    self.start_document_subscription(client, runtime, &run_uid);
}
```

**Document subscription method (follow DocumentViewerPanel pattern):**
```rust
fn start_document_subscription(
    &mut self,
    client: &mut DaqClient,
    runtime: &Runtime,
    run_uid: &str,
) {
    let (tx, rx) = mpsc::channel(100);
    self.document_rx = Some(rx);

    let mut client = client.clone();
    let run_uid = run_uid.to_string();

    self.subscription_task = Some(runtime.spawn(async move {
        match client.stream_documents(Some(&run_uid), vec![]).await {
            Ok(mut stream) => {
                while let Some(result) = stream.next().await {
                    match result {
                        Ok(doc) => {
                            if tx.send(Ok(doc)).await.is_err() { break; }
                        }
                        Err(status) => {
                            let _ = tx.send(Err(format!("gRPC Error: {}", status))).await;
                            break;
                        }
                    }
                }
            }
            Err(e) => {
                let _ = tx.send(Err(format!("Failed to subscribe: {}", e))).await;
            }
        }
    }));
}
```

**Poll documents in ui() method:**
```rust
fn poll_documents(&mut self) {
    let Some(rx) = &mut self.document_rx else { return };

    while let Ok(result) = rx.try_recv() {
        match result {
            Ok(doc) => self.handle_document(doc),
            Err(err) => {
                self.error = Some(err);
                self.execution_complete(false);
            }
        }
    }
}

fn handle_document(&mut self, doc: Document) {
    use daq_proto::daq::document::Payload;

    match doc.payload {
        Some(Payload::Start(start)) => {
            // Store hints for later (movers list identifies actuator positions)
            self.status = Some(format!("Run started: {}", start.run_uid));
        }
        Some(Payload::Event(event)) => {
            self.current_point = event.seq_num as u32;
            // Extract data for plotting - handled in Task 3a
            self.process_event_for_plot(&event);
        }
        Some(Payload::Stop(stop)) => {
            let success = stop.exit_status == "success";
            self.execution_complete(success);
        }
        _ => {}
    }
}

fn execution_complete(&mut self, success: bool) {
    self.execution_state = ExecutionState::Idle;
    if let Some(handle) = self.subscription_task.take() {
        handle.abort();
    }
    self.document_rx = None;

    if success {
        self.status = Some(format!(
            "Scan complete: {} points in {:.1}s",
            self.current_point,
            self.start_time.map(|t| t.elapsed().as_secs_f64()).unwrap_or(0.0)
        ));
    }
}
```

**Progress bar UI with ETA:**
```rust
if self.execution_state == ExecutionState::Running && self.total_points > 0 {
    let progress = self.current_point as f32 / self.total_points as f32;

    // Calculate ETA
    let elapsed = self.start_time.map(|t| t.elapsed()).unwrap_or_default();
    let eta = if self.current_point > 0 {
        let rate = elapsed.as_secs_f64() / self.current_point as f64;
        let remaining = (self.total_points - self.current_point) as f64 * rate;
        format!(", ETA: {}", format_duration(remaining))
    } else {
        String::new()
    };

    let progress_bar = egui::ProgressBar::new(progress)
        .text(format!(
            "{}/{} ({:.1}%){}",
            self.current_point, self.total_points,
            progress * 100.0,
            eta
        ));
    ui.add(progress_bar);
}
```
  </action>
  <verify>
- Start scan triggers document subscription
- Events increment current_point counter
- Progress bar updates during execution
- Progress bar ETA counts down during long scan (50+ points)
- Stop document triggers completion
- Abort cleans up subscription task
  </verify>
  <done>Document streaming active during execution, progress bar shows point count and ETA that updates correctly</done>
</task>

<task type="auto">
  <name>Task 3a: Add plot data collection from events</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**Add plot data state:**
```rust
// Live plot data: detector_id -> Vec<(actuator_position, detector_value)>
plot_data: HashMap<String, Vec<(f64, f64)>>,
// Plot display options
show_plot: bool,
```

**Process events for plot data:**
```rust
fn process_event_for_plot(&mut self, event: &daq_proto::daq::EventDoc) {
    // Extract actuator position from event.positions
    // event.positions is a HashMap<String, f64> where key is device_id
    // The actuator device_id is in self.selected_actuator
    let actuator_pos = self.selected_actuator.as_ref()
        .and_then(|id| event.positions.get(id))
        .copied()
        .unwrap_or(event.seq_num as f64);  // Fallback to sequence number if position not in event

    // Extract detector values from event.data
    // event.data is a HashMap<String, f64> where key is device_id
    for detector_id in &self.selected_detectors {
        if let Some(&value) = event.data.get(detector_id) {
            self.plot_data
                .entry(detector_id.clone())
                .or_insert_with(Vec::new)
                .push((actuator_pos, value));
        }
    }
}
```

**Clear plot on new scan start (in StartScan handler):**
```rust
self.plot_data.clear();
```

**Request repaint during execution (at end of poll_documents()):**
```rust
if self.execution_state == ExecutionState::Running {
    ctx.request_repaint();
}
```

**Note on event structure:** The `EventDoc` proto has:
- `positions: HashMap<String, f64>` - device_id to position for each motor
- `data: HashMap<String, f64>` - device_id to value for each detector

If position data is missing (older daemon version), fall back to sequence number.
  </action>
  <verify>
- `cargo check -p daq-egui` passes
- plot_data HashMap populates during scan execution
- Data clears when starting new scan
- Repaint requested on each document poll
  </verify>
  <done>Plot data collection from EventDoc working with proper field extraction</done>
</task>

<task type="auto">
  <name>Task 3b: Add live 1D plot rendering with egui_plot</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**Add plot style state:**
```rust
plot_style: PlotStyle,

enum PlotStyle {
    LineWithMarkers,
    ScatterOnly,
}
```

**Render live plot (follow SignalPlotterPanel pattern):**
```rust
fn render_live_plot(&mut self, ui: &mut egui::Ui) {
    use egui_plot::{Plot, Line, Points, PlotPoints, Legend};

    // Plot style toggle
    ui.horizontal(|ui| {
        ui.label("Plot:");
        ui.selectable_value(&mut self.plot_style, PlotStyle::LineWithMarkers, "Line");
        ui.selectable_value(&mut self.plot_style, PlotStyle::ScatterOnly, "Scatter");
    });

    let actuator_name = self.selected_actuator.as_deref().unwrap_or("Position");

    Plot::new("scan_live_plot")
        .height(200.0)
        .show_axes(true)
        .show_grid(true)
        .x_axis_label(actuator_name)
        .y_axis_label("Signal")
        .legend(Legend::default())
        .show(ui, |plot_ui| {
            // Preset colors for multiple detectors
            let colors = [
                egui::Color32::from_rgb(255, 100, 100),
                egui::Color32::from_rgb(100, 200, 100),
                egui::Color32::from_rgb(100, 150, 255),
                egui::Color32::from_rgb(255, 200, 100),
            ];

            for (idx, (detector_id, points)) in self.plot_data.iter().enumerate() {
                let color = colors[idx % colors.len()];
                let plot_points: PlotPoints = points.iter()
                    .map(|(x, y)| [*x, *y])
                    .collect();

                match self.plot_style {
                    PlotStyle::LineWithMarkers => {
                        plot_ui.line(
                            Line::new(plot_points.clone())
                                .name(detector_id)
                                .color(color)
                                .width(2.0)
                        );
                        plot_ui.points(
                            Points::new(plot_points)
                                .name(format!("{} pts", detector_id))
                                .color(color)
                                .radius(3.0)
                        );
                    }
                    PlotStyle::ScatterOnly => {
                        plot_ui.points(
                            Points::new(plot_points)
                                .name(detector_id)
                                .color(color)
                                .radius(4.0)
                        );
                    }
                }
            }
        });
}
```

**Integrate plot into UI layout:**
```rust
// In ui() method, after form fields and before control buttons:
if self.scan_mode == ScanMode::OneDimensional {
    ui.separator();

    // Show plot toggle
    ui.checkbox(&mut self.show_plot, "Show Live Plot");

    if self.show_plot && (!self.plot_data.is_empty() || self.execution_state == ExecutionState::Running) {
        self.render_live_plot(ui);
    } else if self.show_plot {
        ui.label("Plot will appear when scan starts...");
    }
}
```
  </action>
  <verify>
- Plot appears when Show Live Plot is checked
- Plot updates as events arrive (points appear)
- Line/Scatter toggle changes visualization
- Multiple detectors show with different colors
- Plot clears when new scan starts
  </verify>
  <done>Live 1D plot displays scan data in real-time with line/scatter toggle</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build -p daq-egui` succeeds
2. `cargo clippy -p daq-egui --all-targets` passes
3. Start button validates form before execution
4. Document stream subscription starts on scan start
5. Progress bar updates during execution with ETA
6. Live plot shows data points as they arrive
7. Abort button stops execution immediately
8. Stop document triggers completion state
</verification>

<success_criteria>
- User can start a 1D scan from the form
- Progress bar shows current point and estimated time remaining
- Live plot updates in real-time as data arrives
- User can toggle between line and scatter plot styles
- Abort immediately stops execution and cleans up
</success_criteria>

<output>
After completion, create `.planning/phases/01-form-based-scan-builder/01-02-SUMMARY.md`
</output>
