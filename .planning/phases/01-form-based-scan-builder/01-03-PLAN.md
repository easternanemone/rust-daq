---
phase: 01-form-based-scan-builder
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - crates/daq-egui/src/panels/scan_builder.rs
autonomous: false  # Has human-verify checkpoint

must_haves:
  truths:
    - "User can configure and execute 2D grid scans"
    - "User can see 2D scan data visualized (heatmap or scatter)"
    - "User sees completion summary after scan finishes"
    - "Data auto-saves to disk without user intervention"
  artifacts:
    - path: "crates/daq-egui/src/panels/scan_builder.rs"
      provides: "2D grid scan execution and visualization"
      contains: "grid_scan"
  key_links:
    - from: "crates/daq-egui/src/panels/scan_builder.rs"
      to: "client.queue_plan()"
      via: "grid_scan plan type"
      pattern: "\"grid_scan\""
---

<objective>
Complete 2D grid scan support with visualization and add completion summary.

Purpose: Enable scientists to run full 2D parameter sweeps with appropriate visualization, and provide clear feedback when scans complete including saved file location.

Output: 2D grid scan form and execution, 2D scatter/heatmap visualization, completion summary panel showing duration and save path.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-form-based-scan-builder/01-CONTEXT.md
@.planning/phases/01-form-based-scan-builder/01-RESEARCH.md

# Prior plan context:
@.planning/phases/01-form-based-scan-builder/01-01-PLAN.md
@.planning/phases/01-form-based-scan-builder/01-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 2D grid scan form and execution</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**2D scan form fields already exist from Plan 01. Extend StartScan to handle 2D mode:**

In the Start button click handler, check `scan_mode`:
```rust
let (plan_type, parameters, device_mapping) = match self.scan_mode {
    ScanMode::OneDimensional => {
        let mut params = HashMap::new();
        params.insert("start_position".to_string(), self.start_1d.clone());
        params.insert("stop_position".to_string(), self.stop_1d.clone());
        params.insert("num_points".to_string(), self.points_1d.clone());

        let mut devices = HashMap::new();
        devices.insert("motor".to_string(),
            self.selected_actuator.clone().unwrap());
        devices.insert("detector".to_string(),
            self.selected_detectors.first().cloned().unwrap());

        ("line_scan".to_string(), params, devices)
    }
    ScanMode::TwoDimensional => {
        let mut params = HashMap::new();
        // X axis (fast/inner)
        params.insert("x_start".to_string(), self.x_start.clone());
        params.insert("x_stop".to_string(), self.x_stop.clone());
        params.insert("x_points".to_string(), self.x_points.clone());
        // Y axis (slow/outer)
        params.insert("y_start".to_string(), self.y_start.clone());
        params.insert("y_stop".to_string(), self.y_stop.clone());
        params.insert("y_points".to_string(), self.y_points.clone());

        let mut devices = HashMap::new();
        devices.insert("x_motor".to_string(),
            self.selected_actuator_x.clone().unwrap());
        devices.insert("y_motor".to_string(),
            self.selected_actuator_y.clone().unwrap());
        devices.insert("detector".to_string(),
            self.selected_detectors.first().cloned().unwrap());

        ("grid_scan".to_string(), params, devices)
    }
};

self.pending_action = Some(PendingAction::StartScan {
    plan_type,
    parameters,
    device_mapping,
});
```

**Update total_points calculation for 2D:**
```rust
self.total_points = match self.scan_mode {
    ScanMode::OneDimensional => self.points_1d.parse().unwrap_or(0),
    ScanMode::TwoDimensional => {
        let x_pts: u32 = self.x_points.parse().unwrap_or(0);
        let y_pts: u32 = self.y_points.parse().unwrap_or(0);
        x_pts * y_pts
    }
};
```

**Update validation for 2D mode:**
```rust
fn validate_form(&mut self) {
    self.validation_errors.clear();

    match self.scan_mode {
        ScanMode::OneDimensional => {
            self.validate_numeric_field("start_1d", &self.start_1d);
            self.validate_numeric_field("stop_1d", &self.stop_1d);
            self.validate_points_field("points_1d", &self.points_1d);

            if self.selected_actuator.is_none() {
                self.validation_errors.insert("actuator", "Select an actuator".into());
            }
        }
        ScanMode::TwoDimensional => {
            self.validate_numeric_field("x_start", &self.x_start);
            self.validate_numeric_field("x_stop", &self.x_stop);
            self.validate_points_field("x_points", &self.x_points);
            self.validate_numeric_field("y_start", &self.y_start);
            self.validate_numeric_field("y_stop", &self.y_stop);
            self.validate_points_field("y_points", &self.y_points);

            if self.selected_actuator_x.is_none() {
                self.validation_errors.insert("actuator_x", "Select X actuator".into());
            }
            if self.selected_actuator_y.is_none() {
                self.validation_errors.insert("actuator_y", "Select Y actuator".into());
            }
        }
    }

    if self.selected_detectors.is_empty() {
        self.validation_errors.insert("detectors", "Select at least one detector".into());
    }
}
```
  </action>
  <verify>
- 2D mode form shows both X and Y axis parameters
- Validation works for 2D (requires both actuators, both axes)
- Start button builds grid_scan plan type with correct parameters
- Total points calculated as X * Y
  </verify>
  <done>2D grid scan form validation and plan construction working</done>
</task>

<task type="auto">
  <name>Task 2: Add 2D visualization (scatter plot with color-coded values)</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**Add 2D plot data structure:**
```rust
// 2D plot data: Vec<(x_pos, y_pos, value)>
plot_data_2d: Vec<(f64, f64, f64)>,
plot_2d_style: Plot2DStyle,

enum Plot2DStyle {
    ColoredScatter,  // Points colored by value
    // Heatmap,      // Future: egui::ColorImage-based
}
```

**Process events for 2D plot:**
```rust
fn process_event_for_plot_2d(&mut self, event: &daq_proto::daq::EventDoc) {
    // Extract X position
    let x_pos = self.selected_actuator_x.as_ref()
        .and_then(|id| event.positions.get(id))
        .copied()
        .unwrap_or(0.0);

    // Extract Y position
    let y_pos = self.selected_actuator_y.as_ref()
        .and_then(|id| event.positions.get(id))
        .copied()
        .unwrap_or(0.0);

    // Extract detector value (use first detector)
    let value = self.selected_detectors.first()
        .and_then(|id| event.data.get(id))
        .copied()
        .unwrap_or(0.0);

    self.plot_data_2d.push((x_pos, y_pos, value));
}
```

**Update handle_document to call correct plot function:**
```rust
Some(Payload::Event(event)) => {
    self.current_point = event.seq_num as u32;
    match self.scan_mode {
        ScanMode::OneDimensional => self.process_event_for_plot(&event),
        ScanMode::TwoDimensional => self.process_event_for_plot_2d(&event),
    }
}
```

**Render 2D scatter plot with color mapping:**
```rust
fn render_2d_plot(&self, ui: &mut egui::Ui) {
    use egui_plot::{Plot, Points, PlotPoints};

    if self.plot_data_2d.is_empty() {
        ui.label("Waiting for 2D scan data...");
        return;
    }

    // Calculate value range for color mapping
    let (min_val, max_val) = self.plot_data_2d.iter()
        .fold((f64::INFINITY, f64::NEG_INFINITY), |(min, max), (_, _, v)| {
            (min.min(*v), max.max(*v))
        });

    let x_label = self.selected_actuator_x.as_deref().unwrap_or("X");
    let y_label = self.selected_actuator_y.as_deref().unwrap_or("Y");

    Plot::new("scan_2d_plot")
        .height(300.0)
        .data_aspect(1.0)  // Square aspect for grid
        .show_axes(true)
        .show_grid(true)
        .x_axis_label(x_label)
        .y_axis_label(y_label)
        .show(ui, |plot_ui| {
            // Color each point based on value (blue -> red gradient)
            for &(x, y, value) in &self.plot_data_2d {
                let normalized = if max_val > min_val {
                    ((value - min_val) / (max_val - min_val)).clamp(0.0, 1.0)
                } else {
                    0.5
                };

                // Blue (cold) to Red (hot) gradient
                let r = (normalized * 255.0) as u8;
                let b = ((1.0 - normalized) * 255.0) as u8;
                let color = egui::Color32::from_rgb(r, 50, b);

                plot_ui.points(
                    Points::new(PlotPoints::new(vec![[x, y]]))
                        .color(color)
                        .radius(5.0)
                );
            }
        });

    // Color scale legend
    ui.horizontal(|ui| {
        ui.label(format!("Value: {:.2}", min_val));
        // Draw gradient bar
        let (rect, _) = ui.allocate_exact_size(egui::vec2(100.0, 15.0), egui::Sense::hover());
        let painter = ui.painter_at(rect);
        for i in 0..100 {
            let t = i as f32 / 100.0;
            let r = (t * 255.0) as u8;
            let b = ((1.0 - t) * 255.0) as u8;
            let color = egui::Color32::from_rgb(r, 50, b);
            let x = rect.min.x + t * rect.width();
            painter.line_segment(
                [egui::pos2(x, rect.min.y), egui::pos2(x, rect.max.y)],
                egui::Stroke::new(1.0, color),
            );
        }
        ui.label(format!("{:.2}", max_val));
    });
}
```

**Integrate 2D plot into UI:**
```rust
// In ui() method, show appropriate plot based on mode
if self.show_plot && (!self.plot_data.is_empty() || !self.plot_data_2d.is_empty()
    || self.execution_state == ExecutionState::Running)
{
    match self.scan_mode {
        ScanMode::OneDimensional => self.render_live_plot(ui),
        ScanMode::TwoDimensional => self.render_2d_plot(ui),
    }
}
```

**Clear 2D data on new scan:**
```rust
self.plot_data.clear();
self.plot_data_2d.clear();
```
  </action>
  <verify>
- 2D plot renders during grid scan execution
- Points are color-coded by detector value (blue to red)
- Color scale legend shows min/max values
- Plot aspect ratio is appropriate for grid data
  </verify>
  <done>2D colored scatter plot displays grid scan data in real-time</done>
</task>

<task type="auto">
  <name>Task 3: Add completion summary panel</name>
  <files>crates/daq-egui/src/panels/scan_builder.rs</files>
  <action>
**Add completion summary state:**
```rust
// Completion summary (shown after scan completes)
show_completion_summary: bool,
completion_summary: Option<CompletionSummary>,

struct CompletionSummary {
    run_uid: String,
    exit_status: String,
    total_points: u32,
    duration_secs: f64,
    saved_path: Option<String>,  // From DocumentWriter output
}
```

**Capture completion data from Stop document:**
```rust
Some(Payload::Stop(stop)) => {
    let duration = self.start_time
        .map(|t| t.elapsed().as_secs_f64())
        .unwrap_or(0.0);

    self.completion_summary = Some(CompletionSummary {
        run_uid: stop.run_uid.clone(),
        exit_status: stop.exit_status.clone(),
        total_points: stop.num_events as u32,
        duration_secs: duration,
        // DocumentWriter saves to data/{run_uid}.h5 or .csv
        saved_path: Some(format!("data/{}.h5", stop.run_uid)),
    });
    self.show_completion_summary = true;

    let success = stop.exit_status == "success";
    self.execution_complete(success);
}
```

**Render completion summary window:**
```rust
fn render_completion_summary(&mut self, ctx: &egui::Context) {
    let Some(summary) = &self.completion_summary else { return };

    egui::Window::new("Scan Complete")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            // Status icon and heading
            let (icon, color) = if summary.exit_status == "success" {
                ("Check", egui::Color32::GREEN)
            } else if summary.exit_status == "abort" {
                ("Stopped", egui::Color32::YELLOW)
            } else {
                ("Error", egui::Color32::RED)
            };

            ui.horizontal(|ui| {
                ui.colored_label(color, icon);
                ui.heading(format!("Scan {}", summary.exit_status));
            });

            ui.separator();

            // Summary details in grid
            egui::Grid::new("completion_grid")
                .num_columns(2)
                .spacing([20.0, 4.0])
                .show(ui, |ui| {
                    ui.label("Run ID:");
                    ui.monospace(&summary.run_uid);
                    ui.end_row();

                    ui.label("Duration:");
                    ui.label(format_duration(summary.duration_secs));
                    ui.end_row();

                    ui.label("Total Points:");
                    ui.label(summary.total_points.to_string());
                    ui.end_row();

                    if let Some(path) = &summary.saved_path {
                        ui.label("Saved to:");
                        ui.monospace(path);
                        ui.end_row();
                    }
                });

            ui.separator();

            ui.horizontal(|ui| {
                if ui.button("Close").clicked() {
                    self.show_completion_summary = false;
                }

                // Optional: copy run_uid to clipboard
                if ui.button("Copy Run ID").clicked() {
                    ui.output_mut(|o| o.copied_text = summary.run_uid.clone());
                }
            });
        });
}
```

**Call summary render in ui():**
```rust
// At the end of ui() method, after all other rendering
if self.show_completion_summary {
    self.render_completion_summary(ui.ctx());
}
```

**Note on auto-save:**
The DocumentWriter in daq-storage automatically subscribes to document streams and writes to disk. No explicit integration is needed in the ScanBuilderPanel - data persistence happens transparently on the daemon side.

Add a note in the UI:
```rust
// In the form, show save format info
ui.small("Data auto-saves to HDF5 during acquisition");
```
  </action>
  <verify>
- Completion summary window appears after scan finishes
- Shows run ID, duration, point count, and save path
- Different status colors for success/abort/error
- Close button dismisses the summary
- Copy Run ID button works
  </verify>
  <done>Completion summary panel displays scan results with save path</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete form-based scan builder with 1D/2D scans, live plotting, and completion summary</what-built>
  <how-to-verify>
1. Start the daemon: `cargo run -p daq-bin -- daemon --port 50051`
2. Start the GUI: `cargo run -p daq-egui`
3. Open the "Scan Builder" tab
4. Verify device list populates (mock devices should appear)
5. Test 1D scan:
   - Select a mock motor as actuator
   - Select a mock detector
   - Enter start: 0, stop: 10, points: 11
   - Verify preview shows "11 points, ~1.1s"
   - Click Start
   - Watch live plot update
   - Wait for completion summary
6. Test 2D scan:
   - Toggle to 2D mode
   - Select X and Y actuators
   - Enter X: 0-5 (6 points), Y: 0-3 (4 points)
   - Verify preview shows "24 points"
   - Click Start
   - Watch 2D scatter plot update with colors
   - Verify completion summary shows correct totals
7. Test abort:
   - Start a long scan (100+ points)
   - Click Abort
   - Verify execution stops immediately
   - Verify completion summary shows "abort" status
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build -p daq-egui` succeeds
2. `cargo clippy -p daq-egui --all-targets` passes
3. 2D grid scan can be configured and executed
4. 2D scatter plot shows data with color mapping
5. Completion summary appears after scan finishes
6. Summary shows duration, point count, and save path
</verification>

<success_criteria>
- User can configure and execute 2D grid scans
- 2D visualization shows color-coded scatter plot
- Completion summary displays after scan finishes
- Summary includes duration, points, and saved file path
- Data auto-saves via DocumentWriter (no explicit user action)
</success_criteria>

<output>
After completion, create `.planning/phases/01-form-based-scan-builder/01-03-SUMMARY.md`
</output>
