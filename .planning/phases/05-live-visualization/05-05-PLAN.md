---
phase: 05-live-visualization
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User sees live camera frames displayed in image panel during acquisition"
    - "User sees live line plots updating in plot panels during acquisition"
  artifacts:
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Camera and plot streaming wiring"
      contains: "frame_tx.try_send|data_tx.try_send"
  key_links:
    - from: "ExperimentDesignerPanel"
      to: "gRPC StreamFrames"
      via: "spawn streaming task that sends to frame_tx"
      pattern: "stream_frames.*frame_tx"
    - from: "ExperimentDesignerPanel"
      to: "gRPC StreamDocuments"
      via: "spawn streaming task that extracts Event data and sends to data_tx"
      pattern: "stream_documents.*data_tx"
---

<objective>
Wire camera frame streaming and document data extraction to LiveVisualizationPanel channels.

Purpose: Close the data flow gaps identified in Phase 5 verification - frame_tx and data_tx channels exist but are never used to send data to the LiveVisualizationPanel.

Output: Live camera frames and plot data flow from gRPC streams to visualization panel during experiment execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-live-visualization/05-04-SUMMARY.md
@.planning/phases/05-live-visualization/05-VERIFICATION.md

## Reference Patterns (existing working implementations)

### Camera streaming pattern (from image_viewer.rs):
```rust
// Lines 1548-1651: spawn async task that subscribes to gRPC StreamFrames
let stream = match client.stream_frames(&device_id, max_fps, quality).await {
    Ok(s) => s,
    Err(e) => { /* handle error */ return; }
};

// Loop over stream and send to channel
while let Some(result) = stream.next().await {
    match result {
        Some(Ok(frame_data)) => {
            let update = FrameUpdate::from(frame_data);
            match frame_tx.try_send(update) {
                Ok(()) => { /* success */ }
                Err(TrySendError::Full(_)) => { /* drop frame */ }
                Err(TrySendError::Disconnected(_)) => { break; }
            }
        }
        // ...
    }
}
```

### Document streaming pattern (from scan_builder.rs):
```rust
// Lines 440-460: spawn async task for document stream
match client.stream_documents(run_uid, vec![]).await {
    Ok(mut stream) => {
        while let Some(result) = stream.next().await {
            match result {
                Ok(doc) => {
                    // Process doc.payload for Event documents
                    if let Some(Payload::Event(event)) = doc.payload {
                        // Extract scalar values from event.data: HashMap<String, f64>
                        for (device_id, value) in event.data {
                            // Send to data_tx
                        }
                    }
                }
                // ...
            }
        }
    }
}
```

## Key Types

From live_visualization.rs:
- `FrameUpdate { device_id, width, height, data: Vec<u8>, frame_number, timestamp_ns }`
- `DataUpdate { device_id, value: f64, timestamp_secs: f64 }`
- `FrameUpdateSender = mpsc::SyncSender<FrameUpdate>`
- `DataUpdateSender = mpsc::SyncSender<DataUpdate>`

From daq_proto::daq:
- `Document { doc_type, payload: Option<Payload> }`
- `Payload::Event(EventDocument { data: HashMap<String, f64>, timestamps, ... })`
- `FrameData { device_id, width, height, data, frame_number, timestamp_ns, ... }`

## Current State

ExperimentDesignerPanel has:
- `frame_tx: Option<FrameUpdateSender>` (created in start_visualization, stored, never used)
- `data_tx: Option<DataUpdateSender>` (created in start_visualization, stored, never used)
- `extract_detectors()` returns `(Vec<String>, Vec<String>)` - camera IDs and plot IDs

Missing:
1. Async task to subscribe to StreamFrames for each camera and send FrameUpdates
2. Async task to subscribe to StreamDocuments and extract Event data for plots
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire camera streaming to frame_tx</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Add camera streaming subscription that sends FrameUpdate to frame_tx.

1. Add new imports at top of file:
   - `use futures::StreamExt;`
   - `use daq_proto::daq::StreamQuality;`
   - `use std::sync::mpsc::TrySendError;`

2. Add field to ExperimentDesignerPanel struct:
   - `camera_stream_tasks: Vec<tokio::task::JoinHandle<()>>` (for cleanup on stop)

3. Update start_visualization signature to accept borrowed client and runtime:
   `fn start_visualization(&mut self, client: &DaqClient, runtime: &Runtime)`

4. In start_visualization(), BEFORE storing senders in self, spawn streaming tasks using LOCAL variables:
   ```rust
   fn start_visualization(&mut self, client: &DaqClient, runtime: &Runtime) {
       // Extract detectors from graph
       let (cameras, plots) = self.extract_detectors();

       // Only create visualization if there are detectors
       if cameras.is_empty() && plots.is_empty() {
           return;
       }

       // Clear any previous stream tasks (cleanup for repeated calls)
       for handle in self.camera_stream_tasks.drain(..) {
           handle.abort();
       }

       // Create channels (LOCAL variables)
       let (frame_tx, frame_rx) = frame_channel();
       let (data_tx, data_rx) = data_channel();

       // Create and configure panel
       let mut panel = LiveVisualizationPanel::new();
       panel.configure_detectors(cameras.clone(), plots.clone());
       panel.set_frame_receiver(frame_rx);
       panel.set_data_receiver(data_rx);
       panel.start();

       // Spawn camera streaming tasks BEFORE storing senders
       // Use LOCAL frame_tx, not self.frame_tx
       for camera_id in cameras {
           let tx = frame_tx.clone();  // Clone LOCAL variable
           let client = client.clone();

           let handle = runtime.spawn(async move {
               // Start stream (30 FPS preview quality for live viz)
               match client.stream_frames(&camera_id, 30, StreamQuality::Preview).await {
                   Ok(mut stream) => {
                       while let Some(result) = stream.next().await {
                           match result {
                               Ok(frame_data) => {
                                   let update = FrameUpdate {
                                       device_id: camera_id.clone(),
                                       width: frame_data.width,
                                       height: frame_data.height,
                                       data: frame_data.data,
                                       frame_number: frame_data.frame_number,
                                       timestamp_ns: frame_data.timestamp_ns,
                                   };
                                   if tx.try_send(update).is_err() {
                                       // Channel full or closed - continue trying
                                   }
                               }
                               Err(e) => {
                                   tracing::warn!(device = %camera_id, error = %e, "Camera stream error");
                                   break;
                               }
                           }
                       }
                   }
                   Err(e) => {
                       tracing::error!(device = %camera_id, error = %e, "Failed to start camera stream");
                   }
               }
           });
           self.camera_stream_tasks.push(handle);
       }

       // THEN store panel and senders for later cleanup
       self.visualization_panel = Some(panel);
       self.frame_tx = Some(frame_tx);
       self.data_tx = Some(data_tx);
   }
   ```

5. Update caller in run_experiment() (around line 853):
   - Current has early returns for None client/runtime, so after those checks we have valid references
   - Change `self.start_visualization();` to:
     ```rust
     // client and runtime are already validated as Some above
     let client = client.unwrap();
     let runtime = runtime.unwrap();
     self.start_visualization(client, runtime);
     ```
   - Note: The early returns on lines 807-814 guard that client/runtime are Some

6. In stop_visualization(), abort all camera stream tasks:
   ```rust
   for handle in self.camera_stream_tasks.drain(..) {
       handle.abort();
   }
   ```

7. Initialize camera_stream_tasks in Default impl as `Vec::new()`.

Note: The frame_tx is std::sync::mpsc::SyncSender which is Sync+Send, safe to clone into async task.
  </action>
  <verify>
cargo check -p daq-egui 2>&1 | grep -E "^error" || echo "No errors"
rg "frame_tx.*try_send" crates/daq-egui/src/panels/experiment_designer.rs
  </verify>
  <done>
Camera IDs extracted from graph spawn streaming tasks that send FrameUpdate to frame_tx channel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire document streaming to data_tx for plots</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Add document streaming subscription that extracts scalar data and sends DataUpdate to data_tx.

1. Add field to ExperimentDesignerPanel struct:
   - `document_stream_task: Option<tokio::task::JoinHandle<()>>`

2. In start_visualization(), after camera streaming setup but BEFORE storing senders in self, add document stream for plots using LOCAL data_tx:
   ```rust
   // Spawn document stream for plots (still using LOCAL data_tx)
   if !plots.is_empty() {
       let tx = data_tx.clone();  // Clone LOCAL variable
       let client = client.clone();
       let plot_ids: Vec<String> = plots.clone();

       let handle = runtime.spawn(async move {
           // Subscribe to all documents (filter events client-side)
           match client.stream_documents(None, vec![]).await {
               Ok(mut stream) => {
                   while let Some(result) = stream.next().await {
                       match result {
                           Ok(doc) => {
                               use daq_proto::daq::document::Payload;
                               if let Some(Payload::Event(event)) = doc.payload {
                                   // Extract values for configured plot devices
                                   let timestamp_secs = event.time_ns as f64 / 1_000_000_000.0;
                                   for plot_id in &plot_ids {
                                       if let Some(&value) = event.data.get(plot_id) {
                                           let update = DataUpdate {
                                               device_id: plot_id.clone(),
                                               value,
                                               timestamp_secs,
                                           };
                                           if tx.try_send(update).is_err() {
                                               // Channel full or closed
                                           }
                                       }
                                   }
                               }
                           }
                           Err(e) => {
                               tracing::warn!(error = %e, "Document stream error");
                               break;
                           }
                       }
                   }
               }
               Err(e) => {
                   tracing::error!(error = %e, "Failed to start document stream");
               }
           }
       });
       self.document_stream_task = Some(handle);
   }
   ```

3. Also in start_visualization(), cleanup any previous document stream task at the start:
   ```rust
   // Clear any previous document stream task (cleanup for repeated calls)
   if let Some(handle) = self.document_stream_task.take() {
       handle.abort();
   }
   ```

4. In stop_visualization(), abort document stream task:
   ```rust
   if let Some(handle) = self.document_stream_task.take() {
       handle.abort();
   }
   ```

5. Initialize document_stream_task in Default impl as None.

6. Add imports for daq_proto types if not already present:
   - `use daq_proto::daq::document::Payload;` (may need at function level inside async block)
  </action>
  <verify>
cargo check -p daq-egui 2>&1 | grep -E "^error" || echo "No errors"
rg "data_tx.*try_send" crates/daq-egui/src/panels/experiment_designer.rs
  </verify>
  <done>
Plot device IDs extracted from graph configure document stream that filters Event documents and sends DataUpdate to data_tx channel.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo check -p daq-egui` passes with no errors
2. `rg "frame_tx.*try_send|data_tx.*try_send" crates/daq-egui/src/panels/experiment_designer.rs` shows both senders in use
3. The gaps identified in 05-VERIFICATION.md are closed:
   - frame_tx now wired to StreamFrames responses
   - data_tx now wired to Event document data extraction
</verification>

<success_criteria>
- Camera streaming tasks spawn for each camera detector and send FrameUpdate to frame_tx
- Document streaming task spawns for plot detectors and sends DataUpdate to data_tx
- Streaming tasks are properly aborted on stop_visualization()
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-live-visualization/05-05-SUMMARY.md`
</output>
