---
phase: 02-node-graph-editor-core
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - crates/daq-egui/src/graph/serialization.rs
  - crates/daq-egui/src/graph/mod.rs
  - crates/daq-egui/src/panels/experiment_designer.rs
autonomous: false

must_haves:
  truths:
    - "User can save the current graph to a JSON file via File menu or toolbar"
    - "User can load a previously saved graph from a JSON file"
    - "Invalid nodes show validation errors in the status bar or property inspector"
  artifacts:
    - path: "crates/daq-egui/src/graph/serialization.rs"
      provides: "JSON save/load functions"
      contains: "save_graph"
    - path: "crates/daq-egui/src/panels/experiment_designer.rs"
      provides: "Save/Load toolbar buttons and file dialogs"
      contains: "save_graph"
  key_links:
    - from: "crates/daq-egui/src/panels/experiment_designer.rs"
      to: "crates/daq-egui/src/graph/serialization.rs"
      via: "save_graph/load_graph function calls"
      pattern: "serialization::"
---

<objective>
Implement file persistence (save/load JSON) and visual validation error display.

Purpose: File persistence allows users to save work and continue later, or share experiment designs. Visual error display helps users understand when something is wrong with their graph.

Output: Users can save/load graphs to JSON files and see validation errors in status bar/property inspector.

**Note:** Subgraph grouping (EDIT-03) is deferred to a later phase. The node graph foundation must stabilize before adding hierarchical grouping complexity.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-node-graph-editor-core/02-RESEARCH.md
@.planning/phases/02-node-graph-editor-core/02-01-SUMMARY.md
@.planning/phases/02-node-graph-editor-core/02-02-SUMMARY.md
@.planning/phases/02-node-graph-editor-core/02-03-SUMMARY.md

# Current graph module:
@crates/daq-egui/src/graph/mod.rs
@crates/daq-egui/src/graph/nodes.rs
@crates/daq-egui/src/panels/experiment_designer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JSON serialization for graph save/load</name>
  <files>
crates/daq-egui/src/graph/serialization.rs
crates/daq-egui/src/graph/mod.rs
  </files>
  <action>
Create serialization module for saving and loading experiment graphs:

**serialization.rs:**

```rust
use std::path::Path;
use serde::{Deserialize, Serialize};
use egui_snarl::Snarl;
use crate::graph::ExperimentNode;

/// Complete graph state for serialization
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GraphFile {
    /// Version for future compatibility
    pub version: u32,
    /// Optional metadata
    pub metadata: GraphMetadata,
    /// The actual graph data (egui-snarl's Snarl is serde-compatible)
    pub graph: Snarl<ExperimentNode>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct GraphMetadata {
    pub name: String,
    pub description: String,
    pub created: Option<String>,      // ISO 8601 timestamp
    pub modified: Option<String>,     // ISO 8601 timestamp
    pub author: Option<String>,
}

impl GraphFile {
    pub const CURRENT_VERSION: u32 = 1;

    pub fn new(graph: Snarl<ExperimentNode>) -> Self {
        Self {
            version: Self::CURRENT_VERSION,
            metadata: GraphMetadata::default(),
            graph,
        }
    }

    pub fn with_metadata(mut self, metadata: GraphMetadata) -> Self {
        self.metadata = metadata;
        self
    }
}

/// Save graph to JSON file
pub fn save_graph(path: &Path, file: &GraphFile) -> Result<(), String> {
    let json = serde_json::to_string_pretty(file)
        .map_err(|e| format!("Failed to serialize graph: {}", e))?;

    std::fs::write(path, json)
        .map_err(|e| format!("Failed to write file: {}", e))?;

    Ok(())
}

/// Load graph from JSON file
pub fn load_graph(path: &Path) -> Result<GraphFile, String> {
    let json = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let file: GraphFile = serde_json::from_str(&json)
        .map_err(|e| format!("Failed to parse graph file: {}", e))?;

    // Version check for future compatibility
    if file.version > GraphFile::CURRENT_VERSION {
        return Err(format!(
            "Graph file version {} is newer than supported version {}",
            file.version,
            GraphFile::CURRENT_VERSION
        ));
    }

    Ok(file)
}

/// File extension for experiment graphs
pub const GRAPH_FILE_EXTENSION: &str = "expgraph";
pub const GRAPH_FILE_FILTER: &str = "Experiment Graph (*.expgraph)";
```

**mod.rs:**
Add `pub mod serialization;` and export `GraphFile`, `GraphMetadata`, `save_graph`, `load_graph`.
  </action>
  <verify>`cargo check -p daq-egui` compiles with serialization module</verify>
  <done>GraphFile struct serializes graph + metadata; save_graph/load_graph functions work with JSON</done>
</task>

<task type="auto">
  <name>Task 2: Add Save/Load UI with file dialogs</name>
  <files>crates/daq-egui/src/panels/experiment_designer.rs</files>
  <action>
Update ExperimentDesignerPanel to add Save/Load functionality:

```rust
use crate::graph::serialization::{GraphFile, GraphMetadata, save_graph, load_graph, GRAPH_FILE_EXTENSION};

pub struct ExperimentDesignerPanel {
    // ... existing fields ...

    /// Current file path (None if unsaved)
    current_file: Option<std::path::PathBuf>,
    /// Graph metadata
    metadata: GraphMetadata,
    /// Status message for save/load feedback
    status_message: Option<(String, std::time::Instant)>,
}

impl ExperimentDesignerPanel {
    pub fn ui(&mut self, ui: &mut egui::Ui) {
        // Handle keyboard shortcuts
        self.handle_keyboard(ui);

        // Top toolbar
        ui.horizontal(|ui| {
            ui.label("Experiment Designer");
            ui.separator();

            // File operations
            if ui.button("New").clicked() {
                self.new_graph();
            }

            if ui.button("Open...").clicked() {
                self.open_file_dialog();
            }

            if ui.button("Save").clicked() {
                self.save_current();
            }

            if ui.button("Save As...").clicked() {
                self.save_file_dialog();
            }

            ui.separator();

            // Undo/Redo (existing)
            let can_undo = self.history.can_undo();
            if ui.add_enabled(can_undo, egui::Button::new("Undo")).clicked() {
                self.undo();
            }
            let can_redo = self.history.can_redo();
            if ui.add_enabled(can_redo, egui::Button::new("Redo")).clicked() {
                self.redo();
            }

            ui.separator();

            // Show current file name
            if let Some(path) = &self.current_file {
                if let Some(name) = path.file_name() {
                    ui.label(format!("File: {}", name.to_string_lossy()));
                }
            } else {
                ui.label("Unsaved");
            }

            // Show status message (auto-fades)
            if let Some((msg, time)) = &self.status_message {
                if time.elapsed().as_secs() < 3 {
                    ui.separator();
                    ui.label(msg);
                } else {
                    self.status_message = None;
                }
            }
        });

        // ... rest of UI (palette, canvas, inspector) ...
    }

    fn new_graph(&mut self) {
        self.snarl = Snarl::new();
        self.history = Record::new();
        self.current_file = None;
        self.metadata = GraphMetadata::default();
        self.selected_node = None;
        self.set_status("New graph created");
    }

    fn open_file_dialog(&mut self) {
        // Use rfd (rusty file dialogs) for native file picker
        // Add rfd to dependencies if not present
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Experiment Graph", &[GRAPH_FILE_EXTENSION])
            .add_filter("All Files", &["*"])
            .pick_file()
        {
            self.load_from_path(&path);
        }
    }

    fn load_from_path(&mut self, path: &std::path::Path) {
        match load_graph(path) {
            Ok(file) => {
                self.snarl = file.graph;
                self.metadata = file.metadata;
                self.current_file = Some(path.to_path_buf());
                self.history = Record::new();  // Clear history for loaded file
                self.selected_node = None;
                self.set_status(format!("Loaded: {}", path.display()));
            }
            Err(e) => {
                self.set_status(format!("Error: {}", e));
            }
        }
    }

    fn save_current(&mut self) {
        if let Some(path) = self.current_file.clone() {
            self.save_to_path(&path);
        } else {
            self.save_file_dialog();
        }
    }

    fn save_file_dialog(&mut self) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Experiment Graph", &[GRAPH_FILE_EXTENSION])
            .set_file_name("experiment.expgraph")
            .save_file()
        {
            self.save_to_path(&path);
        }
    }

    fn save_to_path(&mut self, path: &std::path::Path) {
        // Update modification timestamp
        self.metadata.modified = Some(chrono::Utc::now().to_rfc3339());
        if self.metadata.created.is_none() {
            self.metadata.created = self.metadata.modified.clone();
        }

        let file = GraphFile::new(self.snarl.clone())
            .with_metadata(self.metadata.clone());

        match save_graph(path, &file) {
            Ok(()) => {
                self.current_file = Some(path.to_path_buf());
                self.set_status(format!("Saved: {}", path.display()));
            }
            Err(e) => {
                self.set_status(format!("Error: {}", e));
            }
        }
    }

    fn set_status(&mut self, msg: impl Into<String>) {
        self.status_message = Some((msg.into(), std::time::Instant::now()));
    }

    // Add Ctrl+S/Ctrl+O to handle_keyboard
    fn handle_keyboard(&mut self, ui: &mut egui::Ui) {
        // Ctrl+S = Save
        if ui.input(|i| i.modifiers.command && i.key_pressed(egui::Key::S)) {
            self.save_current();
        }

        // Ctrl+O = Open
        if ui.input(|i| i.modifiers.command && i.key_pressed(egui::Key::O)) {
            self.open_file_dialog();
        }

        // ... existing undo/redo shortcuts ...
    }
}
```

Add `rfd` and `chrono` dependencies to Cargo.toml if not present:
```toml
rfd = "0.14"      # Rusty file dialogs
chrono = "0.4"    # Timestamps
```

NOTE: If `rfd` has issues (requires async-std or other deps), can use a simpler approach:
- Show a text input field for path
- Or use egui's built-in file drag-drop support
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Launch GUI, add some nodes, click "Save As...", save to file
3. Click "New", then "Open...", load the saved file
4. Verify nodes restored correctly
  </verify>
  <done>Save/Load buttons in toolbar; file dialogs work; Ctrl+S/Ctrl+O shortcuts; status messages show save/load feedback</done>
</task>

<task type="auto">
  <name>Task 3: Add validation error display in status bar and property inspector</name>
  <files>
crates/daq-egui/src/graph/viewer.rs
crates/daq-egui/src/panels/experiment_designer.rs
  </files>
  <action>
Display validation errors in the status bar and property inspector panel. This approach avoids egui-snarl API uncertainty around node customization.

**viewer.rs:**
Extend ExperimentViewer to track validation errors:

```rust
use std::collections::HashMap;
use egui_snarl::NodeId;

pub struct ExperimentViewer {
    pub last_error: Option<String>,
    /// Per-node validation errors
    pub node_errors: HashMap<NodeId, String>,
}

impl ExperimentViewer {
    pub fn new() -> Self {
        Self {
            last_error: None,
            node_errors: HashMap::new(),
        }
    }

    pub fn set_node_error(&mut self, node_id: NodeId, error: String) {
        self.node_errors.insert(node_id, error);
    }

    pub fn clear_node_error(&mut self, node_id: NodeId) {
        self.node_errors.remove(&node_id);
    }

    pub fn clear_all_errors(&mut self) {
        self.node_errors.clear();
        self.last_error = None;
    }

    pub fn error_count(&self) -> usize {
        self.node_errors.len()
    }

    pub fn has_errors(&self) -> bool {
        !self.node_errors.is_empty()
    }
}
```

**experiment_designer.rs:**
Add validation that displays errors in the status bar and property inspector:

```rust
impl ExperimentDesignerPanel {
    pub fn ui(&mut self, ui: &mut egui::Ui) {
        // ... existing toolbar ...

        // Status bar at bottom showing validation errors
        ui.with_layout(egui::Layout::bottom_up(egui::Align::LEFT), |ui| {
            self.show_validation_status_bar(ui);
        });

        // ... canvas and inspector ...
    }

    fn show_validation_status_bar(&mut self, ui: &mut egui::Ui) {
        let error_count = self.viewer.error_count();
        if error_count > 0 {
            ui.horizontal(|ui| {
                ui.colored_label(
                    egui::Color32::from_rgb(255, 100, 100),
                    format!("{} validation error{}", error_count, if error_count == 1 { "" } else { "s" })
                );

                // Show first error as summary
                if let Some((node_id, error)) = self.viewer.node_errors.iter().next() {
                    if let Some(node) = self.snarl.get_node(*node_id) {
                        ui.label(format!("- {}: {}", node.title(), error));
                    }
                }
            });
        } else {
            ui.colored_label(egui::Color32::from_rgb(100, 200, 100), "Graph valid");
        }
    }

    fn show_property_inspector(&mut self, ui: &mut egui::Ui) {
        if let Some(node_id) = self.selected_node {
            // Show validation error for selected node prominently
            if let Some(error) = self.viewer.node_errors.get(&node_id) {
                ui.group(|ui| {
                    ui.colored_label(egui::Color32::RED, "Validation Error:");
                    ui.label(error);
                });
                ui.add_space(8.0);
            }

            // ... existing property editing UI ...
        }
    }

    /// Validate the entire graph and update error display
    fn validate_graph(&mut self) {
        self.viewer.clear_all_errors();

        // Check each node for issues
        for (node_id, node) in self.snarl.nodes() {
            if let Some(error) = self.validate_node(node_id, node) {
                self.viewer.set_node_error(node_id, error);
            }
        }
    }

    fn validate_node(&self, _node_id: NodeId, node: &ExperimentNode) -> Option<String> {
        match node {
            ExperimentNode::Scan { actuator, points, .. } => {
                if actuator.is_empty() {
                    return Some("Actuator not set".to_string());
                }
                if *points == 0 {
                    return Some("Points must be > 0".to_string());
                }
            }
            ExperimentNode::Acquire { detector, .. } => {
                if detector.is_empty() {
                    return Some("Detector not set".to_string());
                }
            }
            ExperimentNode::Move { device, .. } => {
                if device.is_empty() {
                    return Some("Device not set".to_string());
                }
            }
            _ => {}
        }
        None
    }
}
```

Call `validate_graph()` on:
- Graph load
- Node property changes
- Node additions/deletions
- Wire connections/disconnections
  </action>
  <verify>
1. `cargo build -p daq-egui` succeeds
2. Add a Scan node, leave actuator empty
3. See error count in status bar and error message when node selected in inspector
4. Fill in actuator, see "Graph valid" in status bar
  </verify>
  <done>Validation errors display in status bar (error count + summary) and property inspector (detailed error for selected node)</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete node graph editor with:
- Node palette for drag-and-drop creation
- Wire connections between nodes
- Property inspector for editing node parameters
- Undo/redo with Ctrl+Z/Ctrl+Y
- Save/Load to JSON files
- Validation error display in status bar and property inspector
  </what-built>
  <how-to-verify>
1. Launch the GUI with mock daemon
2. Open "Experiment Designer" panel

**Test node creation:**
3. Drag "Scan" from palette to canvas - node should appear
4. Drag "Acquire" from palette - second node should appear
5. Drag wire from Scan output to Acquire input - wire should connect

**Test property editing:**
6. Click on Scan node (or select somehow)
7. In right panel, change "Start" value from 0 to 10
8. Verify the change persists

**Test undo/redo:**
9. Press Ctrl+Z - last change should undo
10. Press Ctrl+Y - change should redo
11. Delete a node, Ctrl+Z to restore it

**Test save/load:**
12. Click "Save As...", save to test.expgraph
13. Click "New" to clear graph
14. Click "Open...", load test.expgraph
15. Verify nodes restored correctly

**Test validation:**
16. Add a Scan node with empty actuator field
17. Check status bar shows error count
18. Select the node, check property inspector shows error message
19. Fill in actuator, verify "Graph valid" appears in status bar

Note any issues or unexpected behavior for the summary.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete (including human verification):

1. **Build verification:**
   ```bash
   cargo build -p daq-egui
   cargo clippy -p daq-egui -- -D warnings
   ```

2. **Serialization verification:**
   - Save graph, check JSON file is valid and human-readable
   - Load graph, verify structure matches original

3. **Validation verification:**
   - Incomplete nodes show errors in status bar and inspector
   - Valid nodes show "Graph valid" status

4. **Complete workflow:**
   - Create graph with multiple nodes
   - Connect them appropriately
   - Save to file
   - Clear and reload
   - Verify full restoration
</verification>

<success_criteria>
- GraphFile struct serializes graph + metadata to JSON
- Save/Load buttons work with native file dialogs
- Ctrl+S saves, Ctrl+O opens
- Status messages confirm save/load operations
- Validation errors display in status bar (count + first error)
- Validation errors display in property inspector for selected node
- Complete editing workflow verified by human tester
</success_criteria>

<output>
After completion, create `.planning/phases/02-node-graph-editor-core/02-04-SUMMARY.md`
</output>
