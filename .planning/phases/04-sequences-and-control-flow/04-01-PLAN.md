---
phase: 04-sequences-and-control-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/daq-egui/src/graph/nodes.rs
  - crates/daq-egui/src/widgets/device_selector.rs
  - crates/daq-egui/src/widgets/mod.rs
  - crates/daq-egui/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Move node has absolute/relative mode toggle"
    - "Move node has wait_settled option"
    - "Wait node supports duration-based and condition-based waits"
    - "Acquire node supports frame count and exposure override"
    - "Loop node supports count-based, condition-based, and infinite termination"
    - "Device selection uses fuzzy-match autocomplete from registry"
  artifacts:
    - path: "crates/daq-egui/src/graph/nodes.rs"
      provides: "Enhanced ExperimentNode with configuration structs"
      contains: "MoveConfig"
    - path: "crates/daq-egui/src/widgets/device_selector.rs"
      provides: "DeviceSelector widget with autocomplete"
      contains: "AutoCompleteTextEdit"
  key_links:
    - from: "crates/daq-egui/src/graph/nodes.rs"
      to: "MoveConfig, WaitConfig, AcquireConfig, LoopConfig"
      via: "struct embedding in ExperimentNode variants"
      pattern: "ExperimentNode::Move.*MoveConfig"
---

<objective>
Enhance ExperimentNode variants with rich configuration structs and add device selection widget with autocomplete.

Purpose: Phase 4 requires Move nodes with absolute/relative modes, Wait nodes with conditional waits, Acquire nodes with burst mode, and Loop nodes with multiple termination modes. This plan creates the data model foundation and device selection UX.

Output: Enhanced nodes.rs with configuration structs, new device_selector.rs widget using egui_autocomplete
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-sequences-and-control-flow/04-CONTEXT.md
@.planning/phases/04-sequences-and-control-flow/04-RESEARCH.md

# Existing code to enhance
@crates/daq-egui/src/graph/nodes.rs
@crates/daq-egui/src/widgets/mod.rs
@crates/daq-egui/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add egui_autocomplete dependency and create DeviceSelector widget</name>
  <files>
    crates/daq-egui/Cargo.toml
    crates/daq-egui/src/widgets/device_selector.rs
    crates/daq-egui/src/widgets/mod.rs
  </files>
  <action>
1. Add egui_autocomplete to daq-egui/Cargo.toml:
   ```toml
   egui_autocomplete = "0.0.10"
   ```

2. Create device_selector.rs with DeviceSelector widget:
   - Struct holds `text: String` and `candidates: Vec<String>`
   - Constructor `new(device_ids: &[String])` initializes candidates
   - Method `show(&mut self, ui: &mut egui::Ui, hint: &str) -> bool` renders AutoCompleteTextEdit
   - Method `selected(&self) -> &str` returns current selection
   - Method `set_selected(&mut self, device_id: &str)` for programmatic selection
   - Method `update_candidates(&mut self, device_ids: &[String])` for refreshing device list

3. Export DeviceSelector in widgets/mod.rs

The widget wraps egui_autocomplete::AutoCompleteTextEdit with a clean API for device selection from registry.
  </action>
  <verify>
    `cargo check -p daq-egui` succeeds with no errors about missing egui_autocomplete
  </verify>
  <done>
    DeviceSelector widget exists and compiles, exported from widgets module
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance ExperimentNode with configuration structs</name>
  <files>
    crates/daq-egui/src/graph/nodes.rs
  </files>
  <action>
Add configuration structs and update ExperimentNode variants:

1. Add MoveMode enum:
   ```rust
   #[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Default)]
   pub enum MoveMode {
       #[default]
       Absolute,
       Relative,
   }
   ```

2. Add MoveConfig struct:
   ```rust
   #[derive(Clone, Debug, Serialize, Deserialize)]
   pub struct MoveConfig {
       pub device: String,
       pub position: f64,
       pub mode: MoveMode,
       pub wait_settled: bool,
   }
   ```

3. Add WaitCondition enum:
   ```rust
   #[derive(Clone, Debug, Serialize, Deserialize)]
   pub enum WaitCondition {
       Duration { milliseconds: f64 },
       Threshold {
           device_id: String,
           operator: ThresholdOp,
           value: f64,
           timeout_ms: f64,
       },
       Stability {
           device_id: String,
           tolerance: f64,
           duration_ms: f64,
           timeout_ms: f64,
       },
   }

   #[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Default)]
   pub enum ThresholdOp {
       #[default]
       LessThan,
       GreaterThan,
       EqualWithin { tolerance: f64 },
   }
   ```

4. Add AcquireConfig struct:
   ```rust
   #[derive(Clone, Debug, Serialize, Deserialize)]
   pub struct AcquireConfig {
       pub detector: String,
       pub exposure_ms: Option<f64>,  // None = use device default
       pub frame_count: u32,          // 1 for single, >1 for burst
   }
   ```

5. Add LoopTermination enum and LoopConfig struct:
   ```rust
   #[derive(Clone, Debug, Serialize, Deserialize)]
   pub enum LoopTermination {
       Count { iterations: u32 },
       Condition {
           device_id: String,
           operator: ThresholdOp,
           value: f64,
           max_iterations: u32,  // Safety limit
       },
       Infinite { max_iterations: u32 },  // Requires manual abort, has safety limit
   }

   #[derive(Clone, Debug, Serialize, Deserialize)]
   pub struct LoopConfig {
       pub termination: LoopTermination,
   }
   ```

6. Update ExperimentNode enum variants to use config structs:
   ```rust
   pub enum ExperimentNode {
       Scan { actuator: String, start: f64, stop: f64, points: u32 },
       Move(MoveConfig),
       Wait { condition: WaitCondition },
       Acquire(AcquireConfig),
       Loop(LoopConfig),
   }
   ```

7. Update all helper methods (node_name, default_*) to work with new structure:
   - `default_move()` returns Move with MoveConfig { device: "", position: 0.0, mode: Absolute, wait_settled: true }
   - `default_wait()` returns Wait with WaitCondition::Duration { milliseconds: 1000.0 }
   - `default_acquire()` returns Acquire with AcquireConfig { detector: "", exposure_ms: None, frame_count: 1 }
   - `default_loop()` returns Loop with LoopConfig { termination: LoopTermination::Count { iterations: 10 } }

Note: Scan variant unchanged (works well as-is). Add impl Default for config structs.
  </action>
  <verify>
    `cargo check -p daq-egui` passes with updated node types
  </verify>
  <done>
    ExperimentNode uses MoveConfig, WaitCondition, AcquireConfig, LoopConfig - all variants compile
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix compilation in dependent code (translation, property_inspector, viewer)</name>
  <files>
    crates/daq-egui/src/graph/translation.rs
    crates/daq-egui/src/widgets/property_inspector.rs
  </files>
  <action>
Update code that matches on ExperimentNode to work with new structure:

1. In translation.rs, update translate_node match arms:
   - `ExperimentNode::Move(config)` extracts config.device, config.position
   - `ExperimentNode::Wait { condition }` handles WaitCondition variants (Duration only for now, others emit warning + fallback)
   - `ExperimentNode::Acquire(config)` extracts config.detector, config.exposure_ms, config.frame_count
   - `ExperimentNode::Loop(config)` extracts config.termination

   For now, keep translation simple:
   - Move: emit MoveTo command, optionally WaitSettled if config.wait_settled
   - Wait: Duration -> Wait command, Threshold/Stability -> emit warning log + fallback to timeout duration
   - Acquire: loop frame_count times with Trigger+Read
   - Loop: same stub (checkpoint only) - Plan 03 enhances this

2. In property_inspector.rs, update match arms to destructure config structs:
   - Move: edit config.device, config.position, config.mode (radio), config.wait_settled (checkbox)
   - Wait: depends on condition variant (Duration: just milliseconds, others: show warning "condition-based waits coming soon")
   - Acquire: edit config.detector, config.exposure_ms (optional DragValue), config.frame_count
   - Loop: depends on termination variant (Count: just iterations, Condition/Infinite: show warning)

For initial compilation fix, use simpler UI that just edits the basic fields. Plan 02 will enhance with full UIs.
  </action>
  <verify>
    `cargo build -p daq-egui` succeeds with no errors
  </verify>
  <done>
    All code compiles with new ExperimentNode structure, basic functionality preserved
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p daq-egui` - no compilation errors
2. `cargo test -p daq-egui` - existing tests pass (may need minor updates for new struct destructuring)
3. `cargo build -p daq-egui` - full build succeeds
</verification>

<success_criteria>
- ExperimentNode::Move uses MoveConfig with mode, wait_settled fields
- ExperimentNode::Wait uses WaitCondition enum with Duration, Threshold, Stability variants
- ExperimentNode::Acquire uses AcquireConfig with exposure_ms, frame_count fields
- ExperimentNode::Loop uses LoopConfig with LoopTermination enum
- DeviceSelector widget exists with AutoCompleteTextEdit
- All existing tests pass
- Translation and property_inspector compile with updated match patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequences-and-control-flow/04-01-SUMMARY.md`
</output>
