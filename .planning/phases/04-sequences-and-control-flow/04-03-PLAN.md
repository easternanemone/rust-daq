---
phase: 04-sequences-and-control-flow
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/daq-egui/src/graph/translation.rs
  - crates/daq-egui/src/graph/validation.rs
autonomous: true

must_haves:
  truths:
    - "Loop node body output connects to nodes that repeat each iteration"
    - "Loop body sub-graph is detected and translated correctly"
    - "Count-based loops unroll body N times in translation"
    - "Condition-based loops emit checkpoint-based structure for runtime evaluation"
    - "Validation warns when relative Move is inside loop body"
    - "Back-edges from loop body to loop ancestors are detected as errors"
  artifacts:
    - path: "crates/daq-egui/src/graph/translation.rs"
      provides: "Loop body expansion with unrolling"
      contains: "translate_loop_body"
    - path: "crates/daq-egui/src/graph/validation.rs"
      provides: "Loop body validation"
      contains: "validate_loop_body"
  key_links:
    - from: "crates/daq-egui/src/graph/translation.rs"
      to: "LoopConfig.termination"
      via: "match on LoopTermination variants"
      pattern: "LoopTermination::Count"
    - from: "crates/daq-egui/src/graph/validation.rs"
      to: "ExperimentNode::Loop"
      via: "body output detection"
      pattern: "output.*== 1.*LoopBody"
---

<objective>
Implement loop body translation with unrolling for count-based loops and validation for loop body connections.

Purpose: Loop nodes need to execute their body sub-graph multiple times. This plan implements the translation logic to detect loop body nodes, unroll them for count-based loops, and validate that loop bodies don't create back-edges to ancestors.

Output: Enhanced translation.rs with loop body detection and unrolling, validation.rs with loop body validation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-sequences-and-control-flow/04-CONTEXT.md
@.planning/phases/04-sequences-and-control-flow/04-RESEARCH.md
@.planning/phases/04-sequences-and-control-flow/04-01-SUMMARY.md

# Code to enhance
@crates/daq-egui/src/graph/translation.rs
@crates/daq-egui/src/graph/validation.rs
@crates/daq-egui/src/graph/nodes.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement loop body sub-graph detection</name>
  <files>
    crates/daq-egui/src/graph/translation.rs
  </files>
  <action>
Add helper functions to detect and extract loop body sub-graphs:

1. Add function `find_loop_body_nodes(loop_node_id: NodeId, snarl: &Snarl<ExperimentNode>) -> Vec<NodeId>`:
   - Find the Loop node's body output pin (output index 1)
   - Get all nodes connected to body output (directly or transitively)
   - Nodes connected to the Next output (index 0) are NOT part of loop body
   - Return body nodes in topological order

   Algorithm:
   ```rust
   fn find_loop_body_nodes(loop_node_id: NodeId, snarl: &Snarl<ExperimentNode>) -> Vec<NodeId> {
       let mut body_nodes = HashSet::new();
       let mut to_visit = VecDeque::new();

       // Find wires from loop's body output (pin 1)
       for (out_pin, in_pin) in snarl.wires() {
           if out_pin.node == loop_node_id && out_pin.output == 1 {
               to_visit.push_back(in_pin.node);
           }
       }

       // BFS to find all reachable nodes from body output
       while let Some(node_id) = to_visit.pop_front() {
           if body_nodes.insert(node_id) {
               // Add this node's outputs to visit
               for (out_pin, in_pin) in snarl.wires() {
                   if out_pin.node == node_id {
                       to_visit.push_back(in_pin.node);
                   }
               }
           }
       }

       // Return in topological order (use existing adjacency/sort)
       // ... sort body_nodes topologically
   }
   ```

2. Add function `is_loop_body_node(node_id: NodeId, loop_id: NodeId, snarl: &Snarl<ExperimentNode>) -> bool`:
   - Used during main translation to skip body nodes (they're handled by loop translation)

3. Ensure body nodes are NOT translated in the main topological traversal - only through loop unrolling
  </action>
  <verify>
    `cargo check -p daq-egui` - helper functions compile
  </verify>
  <done>
    Loop body detection identifies nodes reachable from Loop's body output pin
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement loop body unrolling in translation</name>
  <files>
    crates/daq-egui/src/graph/translation.rs
  </files>
  <action>
Update translate_node and GraphPlan::from_snarl to properly handle Loop nodes:

1. Modify GraphPlan::from_snarl to identify loop bodies BEFORE main traversal:
   - First pass: find all Loop nodes and their body sub-graphs
   - Mark body nodes as "handled by loop"
   - Main traversal skips these nodes

2. Update translate_node for Loop variant:
   ```rust
   ExperimentNode::Loop(config) => {
       match &config.termination {
           LoopTermination::Count { iterations } => {
               // Get body nodes for this loop (passed in or looked up)
               let body_nodes = find_loop_body_nodes(node_id, snarl);

               // Unroll: translate body N times
               for i in 0..*iterations {
                   commands.push(PlanCommand::Checkpoint {
                       label: format!("loop_{:?}_iter_{}_start", node_id, i),
                   });

                   for body_node_id in &body_nodes {
                       if let Some(body_node) = snarl.get_node(*body_node_id) {
                           let (body_cmds, body_movers, body_detectors, body_events) =
                               translate_node(body_node, *body_node_id);
                           commands.extend(body_cmds);
                           movers.extend(body_movers);
                           detectors.extend(body_detectors);
                           events += body_events;
                       }
                   }

                   commands.push(PlanCommand::Checkpoint {
                       label: format!("loop_{:?}_iter_{}_end", node_id, i),
                   });
               }
           }
           LoopTermination::Condition { max_iterations, .. } |
           LoopTermination::Infinite { max_iterations } => {
               // For condition-based and infinite loops, use max_iterations as safety limit
               // Emit warning that true condition evaluation requires RunEngine support
               log::warn!("Condition-based loop at {:?} using max_iterations={} as safety limit",
                          node_id, max_iterations);
               // Same unrolling logic with max_iterations
           }
       }
   }
   ```

3. Pass snarl reference to translate_node (needs signature change) or pre-compute body node lists

4. Update total_events calculation to account for loop iterations
  </action>
  <verify>
    `cargo test -p daq-egui` - add test for loop unrolling translation
  </verify>
  <done>
    Count-based loops unroll body N times, condition-based use max_iterations as fallback
  </done>
</task>

<task type="auto">
  <name>Task 3: Add loop body validation</name>
  <files>
    crates/daq-egui/src/graph/validation.rs
  </files>
  <action>
Add validation functions for loop body integrity:

1. Add function `validate_loop_bodies(snarl: &Snarl<ExperimentNode>) -> Vec<(NodeId, String)>`:
   - For each Loop node, validate its body sub-graph
   - Return list of (node_id, error_message) pairs

2. Add function `validate_loop_body(loop_id: NodeId, snarl: &Snarl<ExperimentNode>) -> Option<String>`:
   - Check for back-edges: body nodes cannot connect to loop or loop's ancestors
   - Check for orphaned body nodes: all body nodes must be reachable from body output

   ```rust
   fn validate_loop_body(loop_id: NodeId, snarl: &Snarl<ExperimentNode>) -> Option<String> {
       // Find loop's ancestors (nodes that can reach loop_id)
       let ancestors = find_ancestors(loop_id, snarl);

       // Find body nodes
       let body_nodes = find_loop_body_nodes(loop_id, snarl);

       // Check for back-edges from body to ancestors
       for body_node in &body_nodes {
           for (out_pin, in_pin) in snarl.wires() {
               if out_pin.node == *body_node {
                   if ancestors.contains(&in_pin.node) || in_pin.node == loop_id {
                       return Some(format!(
                           "Loop body node {:?} connects back to ancestor {:?} - would cause infinite recursion",
                           body_node, in_pin.node
                       ));
                   }
               }
           }
       }

       None
   }
   ```

3. Add helper `find_ancestors(node_id: NodeId, snarl: &Snarl<ExperimentNode>) -> HashSet<NodeId>`:
   - BFS/DFS backward from node_id to find all nodes that can reach it

4. Add warning for relative moves in loop body:
   ```rust
   fn warn_relative_moves_in_loop(loop_id: NodeId, snarl: &Snarl<ExperimentNode>) -> Option<String> {
       let body_nodes = find_loop_body_nodes(loop_id, snarl);
       for body_node_id in body_nodes {
           if let Some(ExperimentNode::Move(config)) = snarl.get_node(body_node_id) {
               if config.mode == MoveMode::Relative {
                   return Some(format!(
                       "Warning: Relative move in loop body (node {:?}) - position will compound each iteration",
                       body_node_id
                   ));
               }
           }
       }
       None
   }
   ```

5. Integrate into validate_graph_structure or create separate validate_loops function called from designer panel
  </action>
  <verify>
    `cargo test -p daq-egui` - add tests for loop body validation
  </verify>
  <done>
    Loop body validation detects back-edges, warns on relative moves in loops
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p daq-egui` - compiles successfully
2. `cargo test -p daq-egui` - all tests pass including new loop tests
3. Add unit tests:
   - test_loop_body_detection: Loop with 2 body nodes, verify detection
   - test_loop_unrolling: 3-iteration loop with Acquire body, verify 3x commands
   - test_loop_backedge_detection: Body node wired to loop input, verify error
</verification>

<success_criteria>
- Loop body nodes are detected via body output (pin 1) traversal
- Count-based loops unroll body N times with checkpoint markers
- Condition-based loops use max_iterations as safety limit with warning log
- Back-edges from body to loop ancestors are detected and reported as errors
- Relative Move in loop body generates warning
- Loop body nodes are not double-translated (skipped in main traversal)
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequences-and-control-flow/04-03-SUMMARY.md`
</output>
