//! High-precision timestamping with NTP synchronization and drift correction.
//!
//! This module provides a robust timestamping system for data acquisition applications,
//! addressing several key challenges in distributed measurement systems:
//!
//! - **Timestamp Source Tracking**: The `Timestamp` struct records the origin of the
//!   timestamp (e.g., system clock, hardware, or NTP), allowing downstream systems
//!   to understand its reliability.
//! - **NTP Synchronization**: The `synchronize_ntp` function allows the application to
//!   synchronize its clock with a trusted external time source, providing a global
//!   time reference.
//! - **Clock Drift Correction**: By tracking the history of NTP synchronizations, the
//!   module calculates and corrects for the drift of the local system clock, improving
//!   accuracy between synchronizations.
//! - **Multi-Instrument Alignment**: A placeholder is provided for a future implementation
//!   of multi-instrument timestamp alignment, a critical feature for correlating
//!   measurements from different sources.
//!
//! ## Usage
//!
//! To use the NTP synchronization, spawn a background task that periodically calls
//! `synchronize_ntp`. The `DaqManagerActor` in `src/app_actor.rs` provides an
//! example of this.
//!
//! ```rust,no_run
//! use daq_core::timestamp;
//! use std::time::Duration;
//!
//! async fn ntp_sync_task() {
//!     loop {
//!         if let Err(e) = timestamp::synchronize_ntp("pool.ntp.org").await {
//!             log::warn!("NTP synchronization failed: {}", e);
//!         }
//!         // Synchronize every hour
//!         tokio::time::sleep(Duration::from_secs(3600)).await;
//!     }
//! }
//! ```
//!
//! Once synchronized, `ntp_now()` can be used to get a corrected timestamp.

use chrono::{DateTime, Utc, Duration};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};
use rsntp::AsyncSntpClient;

/// The source of a timestamp, indicating its origin and accuracy.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TimestampSource {
    /// A timestamp generated by the host system's software clock.
    /// This is the most common but least accurate source. Its accuracy can be
    /// affected by system load and other factors, and it is not guaranteed to be
    /// monotonic.
    System,
    /// A timestamp provided directly by the instrument hardware.
    /// This is highly accurate relative to the instrument's internal clock,
    /// but it may drift relative to a global time standard. The accuracy of
    /// a hardware timestamp depends on the quality of the instrument's oscillator.
    Hardware,
    /// A timestamp synchronized with an NTP server.
    /// This provides a high-accuracy, globally consistent time reference.
    /// The accuracy is typically in the range of a few milliseconds, depending
    /// on network latency.
    NtpSynchronized,
}

/// Represents a measurement timestamp with source and accuracy information.
///
/// This struct is used throughout the DAQ system to provide a consistent and
/// informative way of representing timestamps. By storing the source and an
/// estimate of the accuracy, it allows downstream systems to make informed
-/// decisions about how to process and correlate measurements.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Timestamp {
    /// The time of the measurement.
    pub time: DateTime<Utc>,
    /// The source of the timestamp.
    pub source: TimestampSource,
    /// An estimate of the timestamp's accuracy in nanoseconds.
    ///
    /// For `NtpSynchronized` timestamps, this is typically based on the
    /// round-trip time of the NTP request. For `Hardware` timestamps, it is
    /// based on the known precision of the instrument's clock. For `System`
    /// timestamps, it is typically `None`, as the accuracy is not known.
    #[serde(default)]
    pub accuracy_ns: Option<u64>,
}

impl Timestamp {
    /// Creates a new timestamp from the system clock.
    pub fn now_system() -> Self {
        Self {
            time: Utc::now(),
            source: TimestampSource::System,
            accuracy_ns: None, // System clock accuracy is highly variable
        }
    }

    /// Creates a new timestamp from a hardware source.
    ///
    /// The `time` should be the wall-clock time calculated from the hardware's
    /// raw timestamp and a reference point. The `accuracy_ns` should be based
    /// on the hardware clock's known precision.
    pub fn from_hardware(time: DateTime<Utc>, accuracy_ns: Option<u64>) -> Self {
        Self {
            time,
            source: TimestampSource::Hardware,
            accuracy_ns,
        }
    }
}

/// A record of a single NTP synchronization event.
#[derive(Debug, Clone, Copy)]
struct SyncPoint {
    /// The time at which the synchronization occurred.
    time: DateTime<Utc>,
    /// The measured offset between the system clock and the NTP server.
    offset: Duration,
}

/// Manages the state of NTP synchronization and drift correction.
#[derive(Debug, Clone, Default)]
pub struct NtpSyncState {
    /// A history of the last few synchronization points.
    history: Vec<SyncPoint>,
    /// The calculated clock drift rate in nanoseconds per second.
    drift_rate_ns_per_s: f64,
}

lazy_static::lazy_static! {
    /// Global NTP synchronization state.
    static ref NTP_SYNC_STATE: Arc<Mutex<NtpSyncState>> = Arc::new(Mutex::new(NtpSyncState::default()));
}

/// Synchronizes the system clock with an NTP server and updates the drift calculation.
///
/// This function should be called periodically by a background task to keep the
/// local clock synchronized. It performs the following steps:
///
/// 1. Sends a request to the specified NTP server.
/// 2. Calculates the offset between the local clock and the server's clock.
/// 3. Stores the synchronization event in a history of recent sync points.
/// 4. Recalculates the clock drift rate based on the change in offset over time.
///
/// The drift rate is a simple linear fit of the offset over time, which is
/// sufficient for many applications. More complex drift models could be
/// implemented in the future.
pub async fn synchronize_ntp(server: &str) -> Result<(), rsntp::SntpError> {
    let client = AsyncSntpClient::new();
    let result = client.synchronize(server).await?;
    let sync_time = Utc::now();
    let clock_offset = result.offset();

    let offset = Duration::nanoseconds(clock_offset);

    let mut state = NTP_SYNC_STATE.lock().unwrap();

    let new_point = SyncPoint { time: sync_time, offset };
    state.history.push(new_point);

    // Keep the history size manageable.
    if state.history.len() > 10 {
        state.history.remove(0);
    }

    // Recalculate drift if we have at least two points.
    if state.history.len() > 1 {
        let first = state.history[0];
        let last = *state.history.last().unwrap();

        let time_delta = (last.time - first.time).num_seconds();
        if time_delta > 0 {
            let offset_delta_ns = (last.offset - first.offset).num_nanoseconds().unwrap_or(0);
            state.drift_rate_ns_per_s = offset_delta_ns as f64 / time_delta as f64;
        }
    }

    Ok(())
}

/// Returns the current time, corrected by the NTP offset and clock drift.
///
/// This function should be used to generate timestamps for measurements that
/// require a high degree of accuracy and consistency. It applies the following
/// corrections to the system clock:
///
/// 1. **NTP Offset**: The last measured offset from the NTP server is applied.
/// 2. **Drift Correction**: The calculated drift rate is used to estimate the
///    current offset based on the time since the last synchronization.
///
/// If no NTP synchronization has occurred, this function will fall back to using
/// the system clock. The expected accuracy of an NTP-synchronized timestamp is
/// on the order of a few milliseconds, but this can vary depending on network
/// conditions.
pub fn ntp_now() -> Timestamp {
    let state = NTP_SYNC_STATE.lock().unwrap();
    let now = Utc::now();

    if let Some(last_sync) = state.history.last() {
        let time_since_sync = now - last_sync.time;
        let drift_correction_ns = state.drift_rate_ns_per_s * time_since_sync.num_seconds() as f64;
        let current_offset = last_sync.offset + Duration::nanoseconds(drift_correction_ns as i64);

        Timestamp {
            time: now + current_offset,
            source: TimestampSource::NtpSynchronized,
            // Accuracy depends on round-trip time and other factors,
            // but we can provide a reasonable estimate.
            accuracy_ns: Some(10_000_000), // 10ms
        }
    } else {
        // Fallback to system time if not synchronized
        Timestamp::now_system()
    }
}

// --- Multi-Instrument Timestamp Alignment (Placeholder) ---

/// A collection of correlated timestamps from multiple instruments.
pub struct AlignedTimestamps {
    pub reference_time: DateTime<Utc>,
    pub instrument_timestamps: std::collections::HashMap<String, Timestamp>,
}

/// Aligns timestamps from multiple instruments to a common reference clock.
///
/// **Note:** This is a placeholder for a future implementation.
///
/// The core challenge of multi-instrument alignment is to correct for both the
/// offset and drift of each instrument's internal clock relative to a common
/// reference (e.g., the NTP-synchronized host clock).
///
/// A robust implementation would involve:
/// 1. A calibration routine where each instrument is triggered to generate a
///    timestamp simultaneously. The differences between these timestamps and the
///    reference clock are recorded.
/// 2. Storing these offsets for each instrument.
/// 3. Applying the a_priori offsets to correct the timestamps in real-time
///    during data acquisition.
/// 4. Potentially running a background task to periodically re-calibrate and
///    account for thermal drift in the instrument clocks.
pub fn align_timestamps(_timestamps: &[Timestamp]) -> AlignedTimestamps {
    // In a real implementation, this function would contain the logic
    // described above. For now, we'll just return a placeholder.
    AlignedTimestamps {
        reference_time: Utc::now(),
        instrument_timestamps: std::collections::HashMap::new(),
    }
}
