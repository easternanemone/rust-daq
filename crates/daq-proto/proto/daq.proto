syntax = "proto3";

package daq;

// Control service for script management and execution
service ControlService {
  // Upload a script for later execution
  rpc UploadScript(UploadRequest) returns (UploadResponse);

  // Start execution of an uploaded script
  rpc StartScript(StartRequest) returns (StartResponse);

  // Stop a running script
  rpc StopScript(StopRequest) returns (StopResponse);

  // Get status of a script execution
  rpc GetScriptStatus(StatusRequest) returns (ScriptStatus);

  // Stream system status updates
  rpc StreamStatus(StatusRequest) returns (stream SystemStatus);

  // Stream measurement data
  rpc StreamMeasurements(MeasurementRequest) returns (stream DataPoint);

  // List all uploaded scripts
  rpc ListScripts(ListScriptsRequest) returns (ListScriptsResponse);

  // List all executions (running, completed, errored)
  rpc ListExecutions(ListExecutionsRequest) returns (ListExecutionsResponse);

  // Get daemon version and capabilities
  rpc GetDaemonInfo(DaemonInfoRequest) returns (DaemonInfoResponse);
}

// Request to upload a script
message UploadRequest {
  string script_content = 1;
  string name = 2;
  map<string, string> metadata = 3;
}

// Response from script upload
message UploadResponse {
  string script_id = 1;
  bool success = 2;
  string error_message = 3;
}

// Request to start script execution
message StartRequest {
  string script_id = 1;
  map<string, string> parameters = 2;
}

// Response from starting script
message StartResponse {
  bool started = 1;
  string execution_id = 2;
}

// Request to stop script execution
message StopRequest {
  string execution_id = 1;
  bool force = 2;  // If true, immediately kill; if false, try graceful stop
}

// Response from stopping script
message StopResponse {
  bool stopped = 1;
  string message = 2;  // Explanation of stop result
}

// Request for status information
message StatusRequest {
  string execution_id = 1;
}

// Status of a script execution
message ScriptStatus {
  string execution_id = 1;
  string state = 2; // PENDING, RUNNING, COMPLETED, ERROR, STOPPED
  string error_message = 3;
  uint64 start_time_ns = 4;
  uint64 end_time_ns = 5;

  // Detailed execution info
  string script_id = 6;         // Which script was executed
  uint32 progress_percent = 7;  // Estimated progress (0-100)
  string current_line = 8;      // Current line being executed (if available)
}

// System status snapshot
message SystemStatus {
  string current_state = 1;
  double current_memory_usage_mb = 2;
  map<string, double> live_values = 3;
  uint64 timestamp_ns = 4;
}

// Request for measurement streaming
message MeasurementRequest {
  repeated string channels = 1;
  uint32 max_rate_hz = 2;
}

// Single measurement data point
message DataPoint {
  string channel = 1;
  double value = 2;
  uint64 timestamp_ns = 3;
}

// Request to list all scripts
message ListScriptsRequest {
  // Empty for now, could add filtering later
}

// Response with all uploaded scripts
message ListScriptsResponse {
  repeated ScriptInfo scripts = 1;
}

// Information about a single script
message ScriptInfo {
  string script_id = 1;
  string name = 2;
  uint64 upload_time_ns = 3;
  map<string, string> metadata = 4;
}

// Request to list executions
message ListExecutionsRequest {
  optional string script_id = 1;  // Filter by script ID
  optional string state = 2;      // Filter by state
}

// Response with matching executions
message ListExecutionsResponse {
  repeated ScriptStatus executions = 1;
}

// Request for daemon information
message DaemonInfoRequest {
  // Empty
}

// Daemon information response
message DaemonInfoResponse {
  string version = 1;
  repeated string features = 2;          // e.g., ["storage_hdf5", "networking"]
  repeated string available_hardware = 3; // e.g., ["Stage", "Camera"]
  uint64 uptime_seconds = 4;
}

// =============================================================================
// HardwareService - Direct device control (bd-4x6q)
// =============================================================================

service HardwareService {
  // Discovery and introspection
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse);
  rpc GetDeviceState(DeviceStateRequest) returns (DeviceStateResponse);
  // Real-time device state streaming (bd-6uba)
  rpc SubscribeDeviceState(DeviceStateSubscribeRequest) returns (stream DeviceStateUpdate);

  // Motion Control (for Movable devices)
  rpc MoveAbsolute(MoveRequest) returns (MoveResponse);
  rpc MoveRelative(MoveRequest) returns (MoveResponse);
  rpc StopMotion(StopMotionRequest) returns (StopMotionResponse);
  rpc WaitSettled(WaitSettledRequest) returns (WaitSettledResponse);
  rpc StreamPosition(StreamPositionRequest) returns (stream PositionUpdate);

  // Scalar Readout (for Readable devices)
  rpc ReadValue(ReadValueRequest) returns (ReadValueResponse);
  rpc StreamValues(StreamValuesRequest) returns (stream ValueUpdate);

  // Trigger Control (for Triggerable devices)
  rpc Arm(ArmRequest) returns (ArmResponse);
  rpc Trigger(TriggerRequest) returns (TriggerResponse);

  // Camera/Exposure Control (for ExposureControl devices)
  rpc SetExposure(SetExposureRequest) returns (SetExposureResponse);
  rpc GetExposure(GetExposureRequest) returns (GetExposureResponse);

  // Laser Control (bd-pwjo)
  // Shutter control for devices implementing ShutterControl trait
  rpc SetShutter(SetShutterRequest) returns (SetShutterResponse);
  rpc GetShutter(GetShutterRequest) returns (GetShutterResponse);
  // Wavelength control for devices implementing WavelengthTunable trait
  rpc SetWavelength(SetWavelengthRequest) returns (SetWavelengthResponse);
  rpc GetWavelength(GetWavelengthRequest) returns (GetWavelengthResponse);
  // Emission control for devices implementing EmissionControl trait
  rpc SetEmission(SetEmissionRequest) returns (SetEmissionResponse);
  rpc GetEmission(GetEmissionRequest) returns (GetEmissionResponse);

  // Frame Streaming (for FrameProducer devices)
  rpc StartStream(StartStreamRequest) returns (StartStreamResponse);
  rpc StopStream(StopStreamRequest) returns (StopStreamResponse);
  rpc StreamFrames(StreamFramesRequest) returns (stream FrameData);

  // Device Lifecycle (Stage/Unstage for safe setup/teardown)
  rpc StageDevice(StageDeviceRequest) returns (StageDeviceResponse);
  rpc UnstageDevice(UnstageDeviceRequest) returns (UnstageDeviceResponse);

  // Passthrough Commands (escape hatch for device-specific features)
  // Solves the "Least Common Denominator" problem where generic interfaces
  // lose access to advanced device features
  rpc ExecuteDeviceCommand(DeviceCommandRequest) returns (DeviceCommandResponse);

  // Observable Parameters (QCodes/ScopeFoundry pattern)
  rpc ListParameters(ListParametersRequest) returns (ListParametersResponse);
  rpc GetParameter(GetParameterRequest) returns (ParameterValue);
  rpc SetParameter(SetParameterRequest) returns (SetParameterResponse);
  rpc StreamParameterChanges(StreamParameterChangesRequest) returns (stream ParameterChange);

  // Observable Streaming (bd-qqjq)
  rpc StreamObservables(StreamObservablesRequest) returns (stream ObservableValue);
}

// =============================================================================
// Preset Service (bd-akcm)
// =============================================================================

service PresetService {
  rpc ListPresets(ListPresetsRequest) returns (ListPresetsResponse);
  rpc SavePreset(SavePresetRequest) returns (SavePresetResponse);
  rpc LoadPreset(LoadPresetRequest) returns (LoadPresetResponse);
  rpc DeletePreset(DeletePresetRequest) returns (DeletePresetResponse);
  rpc GetPreset(GetPresetRequest) returns (Preset);
}

// --------------------------------------------------------------------------
// Device Discovery Messages
// --------------------------------------------------------------------------

message ListDevicesRequest {
  // Optional filter by capability
  optional string capability_filter = 1; // "movable", "readable", "triggerable", etc.
}

message ListDevicesResponse {
  repeated DeviceInfo devices = 1;
  repeated RegistrationFailure registration_failures = 2;
}

// Information about a device that failed to register
message RegistrationFailure {
  string device_id = 1;
  string device_name = 2;
  string driver_type = 3;
  string error = 4;
}

// Device categorization for GUI organization
enum DeviceCategory {
  DEVICE_CATEGORY_UNSPECIFIED = 0;
  DEVICE_CATEGORY_CAMERA = 1;
  DEVICE_CATEGORY_STAGE = 2;
  DEVICE_CATEGORY_DETECTOR = 3;
  DEVICE_CATEGORY_LASER = 4;
  DEVICE_CATEGORY_POWER_METER = 5;
  DEVICE_CATEGORY_OTHER = 99;
}

// Complete device information including capabilities
message DeviceInfo {
  string id = 1;
  string name = 2;
  string driver_type = 3;  // "ell14", "esp300", "pvcam", "mock_stage", etc.
  DeviceCategory category = 4;  // Device category for GUI grouping

  // Capabilities as flags (DEPRECATED - use 'capabilities' field instead)
  bool is_movable = 10 [deprecated = true];
  bool is_readable = 11 [deprecated = true];
  bool is_triggerable = 12 [deprecated = true];
  bool is_frame_producer = 13 [deprecated = true];
  bool is_exposure_controllable = 14 [deprecated = true];
  bool is_shutter_controllable = 15 [deprecated = true];
  bool is_wavelength_tunable = 16 [deprecated = true];
  bool is_emission_controllable = 17 [deprecated = true];
  bool is_parameterized = 18 [deprecated = true];

  // Device-specific metadata
  DeviceMetadata metadata = 20;

  // Dynamic capability list - canonical source of truth (bd-4myc.2)
  // Values: "movable", "readable", "triggerable", "frame_producer",
  //         "exposure_controllable", "shutter_controllable",
  //         "wavelength_tunable", "emission_controllable", "parameterized"
  repeated string capabilities = 100;
}

message DeviceMetadata {
  // Position units and limits (for Movable devices)
  optional string position_units = 1;
  optional double min_position = 2;
  optional double max_position = 3;

  // Reading units (for Readable devices)
  optional string reading_units = 4;

  // Frame info (for FrameProducer devices)
  optional uint32 frame_width = 10;
  optional uint32 frame_height = 11;
  optional uint32 bits_per_pixel = 12;

  // Exposure limits (for ExposureControl devices)
  optional double min_exposure_ms = 20;
  optional double max_exposure_ms = 21;

  // Wavelength limits (for WavelengthTunable devices, bd-pwjo)
  optional double min_wavelength_nm = 30;
  optional double max_wavelength_nm = 31;
}

message DeviceStateRequest {
  string device_id = 1;
}

message DeviceStateResponse {
  string device_id = 1;
  bool online = 2;

  // Current values (populated based on capabilities)
  optional double position = 10;        // For Movable
  optional double last_reading = 11;    // For Readable
  optional bool armed = 12;             // For Triggerable
  optional bool streaming = 13;         // For FrameProducer
  optional double exposure_ms = 14;     // For ExposureControl
}

// --------------------------------------------------------------------------
// State Synchronization Messages (bd-6uba)
// --------------------------------------------------------------------------

message DeviceStateSubscribeRequest {
  // Empty = all devices
  repeated string device_ids = 1;
  // Rate limit in Hz (0 = unlimited)
  uint32 max_rate_hz = 2;
  // Resume from a prior stream position; if unknown, server sends snapshot
  uint64 last_seen_version = 3;
  // If true, include a full snapshot as first message
  bool include_snapshot = 4;
}

message DeviceStateUpdate {
  string device_id = 1;
  uint64 timestamp_ns = 2;
  // Monotonic per-device version, increments on every change
  uint64 version = 3;
  bool is_snapshot = 4;
  // Sparse map of changed fields encoded as JSON for flexibility
  map<string, string> fields_json = 5;
}

// --------------------------------------------------------------------------
// Motion Control Messages
// --------------------------------------------------------------------------

message MoveRequest {
  string device_id = 1;
  double value = 2;  // Target position (absolute) or distance (relative)

  // Optional: wait for motion to complete before returning
  // If true, response includes actual settled position
  // If false (default), returns immediately after command is sent
  optional bool wait_for_completion = 3;

  // Optional: timeout in milliseconds for wait_for_completion
  // Only used when wait_for_completion is true
  // If not set, uses device default timeout
  optional uint32 timeout_ms = 4;
}

message MoveResponse {
  bool success = 1;
  string error_message = 2;
  double final_position = 3;  // Actual position after move

  // True if position is settled (only meaningful when wait_for_completion was true)
  optional bool settled = 4;
}

message StopMotionRequest {
  string device_id = 1;
}

message StopMotionResponse {
  bool success = 1;
  double stopped_position = 2;
}

message WaitSettledRequest {
  string device_id = 1;
  optional uint32 timeout_ms = 2;  // Optional timeout
}

message WaitSettledResponse {
  bool success = 1;
  bool settled = 2;
  double position = 3;
}

message StreamPositionRequest {
  string device_id = 1;
  uint32 rate_hz = 2;  // Desired update rate
}

message PositionUpdate {
  string device_id = 1;
  double position = 2;
  uint64 timestamp_ns = 3;
  bool is_moving = 4;
}

// --------------------------------------------------------------------------
// Scalar Readout Messages
// --------------------------------------------------------------------------

message ReadValueRequest {
  string device_id = 1;
}

message ReadValueResponse {
  bool success = 1;
  string error_message = 2;
  double value = 3;
  string units = 4;
  uint64 timestamp_ns = 5;
}

message StreamValuesRequest {
  string device_id = 1;
  uint32 rate_hz = 2;  // Desired sample rate
}

message ValueUpdate {
  string device_id = 1;
  double value = 2;
  string units = 3;
  uint64 timestamp_ns = 4;
}

// --------------------------------------------------------------------------
// Trigger Control Messages
// --------------------------------------------------------------------------

message ArmRequest {
  string device_id = 1;
}

message ArmResponse {
  bool success = 1;
  string error_message = 2;
  bool armed = 3;
}

message TriggerRequest {
  string device_id = 1;
}

message TriggerResponse {
  bool success = 1;
  string error_message = 2;
  uint64 trigger_timestamp_ns = 3;
}

// --------------------------------------------------------------------------
// Exposure Control Messages
// --------------------------------------------------------------------------

message SetExposureRequest {
  string device_id = 1;
  double exposure_ms = 2;
}

message SetExposureResponse {
  bool success = 1;
  string error_message = 2;
  double actual_exposure_ms = 3;  // May differ from requested
}

message GetExposureRequest {
  string device_id = 1;
}

message GetExposureResponse {
  double exposure_ms = 1;
}

// --------------------------------------------------------------------------
// Laser Control Messages (bd-pwjo)
// --------------------------------------------------------------------------

// Shutter control (for ShutterControl devices)
message SetShutterRequest {
  string device_id = 1;
  bool open = 2;  // true = open, false = closed
}

message SetShutterResponse {
  bool success = 1;
  string error_message = 2;
  bool is_open = 3;  // Actual state after operation
}

message GetShutterRequest {
  string device_id = 1;
}

message GetShutterResponse {
  bool is_open = 1;
}

// Wavelength control (for WavelengthTunable devices)
message SetWavelengthRequest {
  string device_id = 1;
  double wavelength_nm = 2;
}

message SetWavelengthResponse {
  bool success = 1;
  string error_message = 2;
  double actual_wavelength_nm = 3;  // May differ from requested
}

message GetWavelengthRequest {
  string device_id = 1;
}

message GetWavelengthResponse {
  double wavelength_nm = 1;
}

// Emission control (for EmissionControl devices - laser on/off)
message SetEmissionRequest {
  string device_id = 1;
  bool enabled = 2;  // true = emission on, false = emission off
}

message SetEmissionResponse {
  bool success = 1;
  string error_message = 2;
  bool is_enabled = 3;  // Actual state after operation
}

message GetEmissionRequest {
  string device_id = 1;
}

message GetEmissionResponse {
  bool is_enabled = 1;
}

// --------------------------------------------------------------------------
// Frame Streaming Messages
// --------------------------------------------------------------------------

message StartStreamRequest {
  string device_id = 1;
  optional uint32 frame_count = 2;  // 0 or omitted = continuous
}

message StartStreamResponse {
  bool success = 1;
  string error_message = 2;
}

message StopStreamRequest {
  string device_id = 1;
}

message StopStreamResponse {
  bool success = 1;
  uint64 frames_captured = 2;
}

// Stream quality level for bandwidth/quality tradeoff
enum StreamQuality {
  STREAM_QUALITY_FULL = 0;     // Full resolution (default)
  STREAM_QUALITY_PREVIEW = 1;  // 2x2 binned (~4x smaller)
  STREAM_QUALITY_FAST = 2;     // 4x4 binned (~16x smaller)
}

// Stream frames from a FrameProducer device to GUI
message StreamFramesRequest {
  string device_id = 1;
  uint32 max_fps = 2;  // Rate limit for GUI rendering (0 = no limit)
  StreamQuality quality = 3;  // Quality level for server-side downsampling
}

// Streaming performance metrics for GUI clients
message StreamingMetrics {
  double current_fps = 1;
  uint64 frames_sent = 2;
  uint64 frames_dropped = 3;
  double avg_latency_ms = 4;
}

// Compression algorithm for frame data (bd-7rk0: gRPC improvements)
enum CompressionType {
  COMPRESSION_NONE = 0;      // Uncompressed data
  COMPRESSION_LZ4 = 1;       // LZ4 fast compression (recommended for camera data)
}

// Single frame of image data (bd-183h: extended metadata)
message FrameData {
  string device_id = 1;
  uint32 width = 2;
  uint32 height = 3;
  uint32 bit_depth = 4;  // 8, 12, or 16
  bytes data = 5;        // Raw pixel data (row-major, little-endian for >8-bit)
  uint64 frame_number = 6;
  uint64 timestamp_ns = 7;  // Driver capture timestamp (nanoseconds since epoch)
  optional double exposure_ms = 8;

  // ROI offset in sensor coordinates (bd-183h)
  uint32 roi_x = 10;      // X offset (0 = left edge of sensor)
  uint32 roi_y = 11;      // Y offset (0 = top edge of sensor)

  // Extended metadata (bd-183h)
  optional double temperature_c = 20;    // Sensor temperature at capture
  optional string gain_mode = 21;        // e.g., "HDR", "High Sensitivity"
  optional string readout_speed = 22;    // e.g., "100 MHz"
  optional string trigger_mode = 23;     // e.g., "Timed", "Trigger First"
  optional uint32 binning_x = 24;        // Horizontal binning factor
  optional uint32 binning_y = 25;        // Vertical binning factor
  map<string, string> metadata = 30;     // Extensible key-value metadata
  optional StreamingMetrics metrics = 40; // Streaming performance metrics

  // Compression support (bd-7rk0: gRPC improvements from Rerun analysis)
  CompressionType compression = 50;      // Compression algorithm used for 'data' field
  uint32 uncompressed_size = 51;         // Original size before compression (for decompression buffer)
}

// Arrow Flight ticket for zero-copy bulk data transfer
message FlightTicket {
  string endpoint = 1;  // e.g., "localhost:50052"
  bytes ticket = 2;     // Opaque ticket for DoGet
}

// --------------------------------------------------------------------------
// Device Lifecycle Messages (Stage/Unstage)
// --------------------------------------------------------------------------

message StageDeviceRequest {
  string device_id = 1;
}

message StageDeviceResponse {
  bool success = 1;
  string error_message = 2;
  bool staged = 3;
}

message UnstageDeviceRequest {
  string device_id = 1;
}

message UnstageDeviceResponse {
  bool success = 1;
  string error_message = 2;
}

// --------------------------------------------------------------------------
// Passthrough Commands (Device-Specific Features)
// --------------------------------------------------------------------------

message DeviceCommandRequest {
  string device_id = 1;
  string command = 2;           // Device-specific command name
  string args = 3;              // Command arguments as JSON string
}

message DeviceCommandResponse {
  bool success = 1;
  string error_message = 2;
  string results = 3;           // Command results as JSON string
}

// --------------------------------------------------------------------------
// Observable Parameters (QCodes/ScopeFoundry Pattern)
// --------------------------------------------------------------------------

message ListParametersRequest {
  string device_id = 1;
}

message ListParametersResponse {
  repeated ParameterDescriptor parameters = 1;
}

// Full description of a parameter
message ParameterDescriptor {
  string device_id = 1;
  string name = 2;              // e.g., "exposure_ms", "wavelength"
  string description = 3;
  string dtype = 4;             // "float", "int", "bool", "string", "enum"
  string units = 5;             // e.g., "ms", "nm", "mW"
  bool readable = 6;
  bool writable = 7;

  // Validation constraints
  optional double min_value = 10;
  optional double max_value = 11;
  repeated string enum_values = 12;  // For enum type
}

message GetParameterRequest {
  string device_id = 1;
  string parameter_name = 2;
}

message ParameterValue {
  string device_id = 1;
  string name = 2;
  string value = 3;             // Value as string (type determined by descriptor)
  string units = 4;
  uint64 timestamp_ns = 5;
}

message SetParameterRequest {
  string device_id = 1;
  string parameter_name = 2;
  string value = 3;             // Value as string
}

message SetParameterResponse {
  bool success = 1;
  string error_message = 2;
  string actual_value = 3;      // Value after set (may differ from requested)
}

message StreamParameterChangesRequest {
  optional string device_id = 1;     // Filter by device (empty = all)
  repeated string parameter_names = 2; // Filter by param names (empty = all)
}

message ParameterChange {
  string device_id = 1;
  string name = 2;
  string old_value = 3;
  string new_value = 4;
  string units = 5;
  uint64 timestamp_ns = 6;
  string source = 7;            // "user", "hardware", "script"
}

// --------------------------------------------------------------------------
// Observable Streaming Messages (bd-qqjq)
// --------------------------------------------------------------------------

message StreamObservablesRequest {
  // List of device IDs to stream from (empty = all devices)
  repeated string device_ids = 1;
  // List of observable names to stream (empty = all observables)
  repeated string observable_names = 2;
  // Target sample rate in Hz (0 = as fast as available)
  uint32 sample_rate_hz = 3;
  // Minimum change threshold for sending updates (default: 0.001)
  // Values smaller than this are treated as noise and won't trigger updates
  double deadband = 4;
}

message ObservableValue {
  string device_id = 1;
  string observable_name = 2;
  double value = 3;
  string units = 4;
  uint64 timestamp_ns = 5;
}

// =============================================================================
// Preset Messages (bd-akcm)
// =============================================================================

message Preset {
  PresetMetadata meta = 1;
  // Device configurations keyed by device_id; JSON payload is driver-specific
  map<string, string> device_configs_json = 2;
  // Optional scan template serialized as JSON
  string scan_template_json = 3;
}

message PresetMetadata {
  string preset_id = 1;
  string name = 2;
  string description = 3;
  string author = 4;
  uint64 created_at_ns = 5;
  uint64 updated_at_ns = 6;
  uint32 schema_version = 7;
}

message ListPresetsRequest {}
message ListPresetsResponse {
  repeated PresetMetadata presets = 1;
}

message SavePresetRequest {
  Preset preset = 1;
  bool overwrite = 2;
}
message SavePresetResponse {
  bool saved = 1;
  string message = 2;
}

message LoadPresetRequest {
  string preset_id = 1;
}
message LoadPresetResponse {
  bool applied = 1;
  string message = 2;
}

message DeletePresetRequest {
  string preset_id = 1;
}
message DeletePresetResponse {
  bool deleted = 1;
  string message = 2;
}

message GetPresetRequest {
  string preset_id = 1;
}

// =============================================================================
// ScanService - Coordinated multi-axis scans (bd-4le6)
// =============================================================================
//
// DEPRECATED (v0.6.0): Use RunEngineService instead for declarative experiment
// control with pause/resume/abort capabilities and structured document streaming.
//
// Migration Path:
// - ScanService.CreateScan + StartScan → RunEngineService.QueuePlan + StartEngine
// - ScanService.PauseScan → RunEngineService.PauseEngine
// - ScanService.ResumeScan → RunEngineService.ResumeEngine
// - ScanService.StopScan → RunEngineService.AbortPlan
// - ScanService.StreamScanProgress → RunEngineService.StreamDocuments
//
// This service will be removed in v0.8.0 after a two-release deprecation period.
//
service ScanService {
  // Create a new scan configuration (returns scan_id)
  rpc CreateScan(CreateScanRequest) returns (CreateScanResponse);

  // Start executing a created scan
  rpc StartScan(StartScanRequest) returns (StartScanResponse);

  // Pause scan at next safe point
  rpc PauseScan(PauseScanRequest) returns (PauseScanResponse);

  // Resume a paused scan
  rpc ResumeScan(ResumeScanRequest) returns (ResumeScanResponse);

  // Stop/abort a scan
  rpc StopScan(StopScanRequest) returns (StopScanResponse);

  // Get current scan status
  rpc GetScanStatus(GetScanStatusRequest) returns (ScanStatus);

  // List all scans
  rpc ListScans(ListScansRequest) returns (ListScansResponse);

  // Stream scan progress updates
  rpc StreamScanProgress(StreamScanProgressRequest) returns (stream ScanProgress);
}

// --------------------------------------------------------------------------
// Scan Configuration Messages
// --------------------------------------------------------------------------

// Scan type determines how axes are traversed
enum ScanType {
  SCAN_TYPE_UNSPECIFIED = 0;
  LINE_SCAN = 1;      // Single axis scan
  GRID_SCAN = 2;      // 2D raster scan (snake pattern)
  SNAKE_SCAN = 3;     // Bidirectional raster (more efficient)
  CUSTOM_SCAN = 4;    // User-defined point list
}

// Single axis configuration for scanning
message AxisConfig {
  string device_id = 1;         // Movable device ID
  double start_position = 2;     // Start of scan range
  double end_position = 3;       // End of scan range
  uint32 num_points = 4;         // Number of points (including start and end)
}

// Complete scan configuration
message ScanConfig {
  // Scan axes (first axis is fastest, last is slowest)
  repeated AxisConfig axes = 1;

  // Scan pattern
  ScanType scan_type = 2;

  // Data acquisition settings
  repeated string acquire_device_ids = 3;  // Devices to read at each point
  uint32 triggers_per_point = 4;           // Number of triggers/readings per point
  double dwell_time_ms = 5;                // Settle time before acquisition

  // Camera settings (optional)
  optional string camera_device_id = 10;   // Camera for triggered acquisition
  optional bool arm_camera = 11;           // Auto-arm camera at scan start

  // Optional metadata
  string name = 20;                        // User-friendly scan name
  map<string, string> metadata = 21;       // Custom key-value metadata
}

// Request to create a new scan
message CreateScanRequest {
  ScanConfig config = 1;
}

// Response with created scan ID
message CreateScanResponse {
  bool success = 1;
  string scan_id = 2;
  string error_message = 3;
  uint32 total_points = 4;  // Calculated total scan points
}

// --------------------------------------------------------------------------
// Scan Control Messages
// --------------------------------------------------------------------------

message StartScanRequest {
  string scan_id = 1;
}

message StartScanResponse {
  bool success = 1;
  string error_message = 2;
  uint64 start_time_ns = 3;
}

message PauseScanRequest {
  string scan_id = 1;
}

message PauseScanResponse {
  bool success = 1;
  uint32 paused_at_point = 2;
}

message ResumeScanRequest {
  string scan_id = 1;
}

message ResumeScanResponse {
  bool success = 1;
  string error_message = 2;
}

message StopScanRequest {
  string scan_id = 1;
  bool emergency_stop = 2;  // If true, stop motion immediately
}

message StopScanResponse {
  bool success = 1;
  uint32 points_completed = 2;
  string error_message = 3;
}

// --------------------------------------------------------------------------
// Scan Status Messages
// --------------------------------------------------------------------------

// Scan execution state
enum ScanState {
  SCAN_STATE_UNSPECIFIED = 0;
  SCAN_CREATED = 1;      // Config validated, ready to start
  SCAN_RUNNING = 2;      // Actively executing
  SCAN_PAUSED = 3;       // Paused at safe point
  SCAN_COMPLETED = 4;     // All points acquired
  SCAN_STOPPED = 5;      // Stopped by user
  SCAN_ERROR = 6;        // Error during execution
}

message GetScanStatusRequest {
  string scan_id = 1;
}

message ScanStatus {
  string scan_id = 1;
  ScanState state = 2;
  uint32 current_point = 3;
  uint32 total_points = 4;
  double progress_percent = 5;

  // Timing
  uint64 start_time_ns = 10;
  uint64 elapsed_time_ns = 11;
  optional uint64 estimated_remaining_ns = 12;

  // Error info (if state == SCAN_ERROR)
  string error_message = 20;
}

message ListScansRequest {
  optional ScanState state_filter = 1;  // Filter by state
}

message ListScansResponse {
  repeated ScanStatus scans = 1;
}

// --------------------------------------------------------------------------
// Scan Progress Streaming
// --------------------------------------------------------------------------

message StreamScanProgressRequest {
  string scan_id = 1;
  bool include_data = 2;  // If true, include acquired data in updates
}

// Progress update sent during scan execution
message ScanProgress {
  string scan_id = 1;
  ScanState state = 2;
  uint32 point_index = 3;
  uint32 total_points = 4;
  uint64 timestamp_ns = 5;

  // Current axis positions
  map<string, double> axis_positions = 10;

  // Acquired data at this point (if include_data=true)
  repeated ScanDataPoint data_points = 11;
}

// Data acquired at a single scan point
message ScanDataPoint {
  string device_id = 1;
  double value = 2;
  uint64 timestamp_ns = 3;
  uint32 trigger_index = 4;  // Which trigger within the point (0 to triggers_per_point-1)
}

// =============================================================================
// ModuleService - Experiment modules with runtime instrument assignment (bd-64)
// =============================================================================
//
// Modules are hardware-agnostic experiment controllers inspired by PyMoDAQ and DynExp.
// Key concepts:
//   - Modules operate on abstract "roles" (e.g., "position_source", "power_meter")
//   - Devices are assigned to roles at runtime
//   - Modules can be reconfigured without code changes
//   - Multiple modules can share devices (with coordination)
//
// Example workflow:
//   1. ListModuleTypes() - see available module types
//   2. CreateModule(type="PowerMonitor") - instantiate module
//   3. AssignDevice(role="power_meter", device="newport_1830c") - bind device
//   4. ConfigureModule(params={threshold: 100.0}) - set parameters
//   5. StartModule() - begin monitoring
//   6. StreamModuleEvents() - receive threshold alerts, statistics

service ModuleService {
  // ==========================================================================
  // Module Type Discovery
  // ==========================================================================

  // List available module types (PowerMonitor, DataLogger, PositionTracker, etc.)
  rpc ListModuleTypes(ListModuleTypesRequest) returns (ListModuleTypesResponse);

  // Get detailed info about a specific module type
  rpc GetModuleTypeInfo(GetModuleTypeInfoRequest) returns (ModuleTypeInfo);

  // ==========================================================================
  // Module Lifecycle
  // ==========================================================================

  // Create a new module instance
  rpc CreateModule(CreateModuleRequest) returns (CreateModuleResponse);

  // Delete a module instance (must be stopped first)
  rpc DeleteModule(DeleteModuleRequest) returns (DeleteModuleResponse);

  // List all module instances
  rpc ListModules(ListModulesRequest) returns (ListModulesResponse);

  // Get detailed status of a module instance
  rpc GetModuleStatus(GetModuleStatusRequest) returns (ModuleStatus);

  // ==========================================================================
  // Module Configuration
  // ==========================================================================

  // Update module configuration parameters
  rpc ConfigureModule(ConfigureModuleRequest) returns (ConfigureModuleResponse);

  // Get current module configuration
  rpc GetModuleConfig(GetModuleConfigRequest) returns (ModuleConfig);

  // ==========================================================================
  // Device Assignment (Runtime Instrument Binding)
  // ==========================================================================

  // Assign a device to a module role
  rpc AssignDevice(AssignDeviceRequest) returns (AssignDeviceResponse);

  // Remove device assignment from a role
  rpc UnassignDevice(UnassignDeviceRequest) returns (UnassignDeviceResponse);

  // List all device assignments for a module
  rpc ListAssignments(ListAssignmentsRequest) returns (ListAssignmentsResponse);

  // ==========================================================================
  // Module Execution Control
  // ==========================================================================

  // Start module execution
  rpc StartModule(StartModuleRequest) returns (StartModuleResponse);

  // Pause module execution
  rpc PauseModule(PauseModuleRequest) returns (PauseModuleResponse);

  // Resume paused module
  rpc ResumeModule(ResumeModuleRequest) returns (ResumeModuleResponse);

  // Stop module execution
  rpc StopModule(StopModuleRequest) returns (StopModuleResponse);

  // ==========================================================================
  // Module Data Streaming
  // ==========================================================================

  // Stream events from a module (alerts, state changes, data)
  rpc StreamModuleEvents(StreamModuleEventsRequest) returns (stream ModuleEvent);

  // Stream computed/processed data from a module
  rpc StreamModuleData(StreamModuleDataRequest) returns (stream ModuleDataPoint);
}

// --------------------------------------------------------------------------
// Module Type Discovery Messages
// --------------------------------------------------------------------------

message ListModuleTypesRequest {
  // Optional filter by required capability
  optional string required_capability = 1;  // e.g., "readable" to list modules that need readable devices
}

message ListModuleTypesResponse {
  repeated ModuleTypeSummary module_types = 1;
}

// Brief summary of a module type
message ModuleTypeSummary {
  string type_id = 1;           // e.g., "power_monitor", "data_logger", "position_tracker"
  string display_name = 2;      // e.g., "Power Monitor"
  string description = 3;       // Brief description of what the module does
  repeated string categories = 4;  // e.g., ["monitoring", "threshold"]
}

message GetModuleTypeInfoRequest {
  string type_id = 1;
}

// Detailed information about a module type
message ModuleTypeInfo {
  string type_id = 1;
  string display_name = 2;
  string description = 3;
  string version = 4;

  // Required device roles
  repeated ModuleRole required_roles = 10;

  // Optional device roles
  repeated ModuleRole optional_roles = 11;

  // Configuration parameters
  repeated ModuleParameter parameters = 20;

  // Event types this module can emit
  repeated string event_types = 30;

  // Data types this module produces
  repeated string data_types = 31;
}

// A role that a device can fill within a module
message ModuleRole {
  string role_id = 1;              // e.g., "power_meter", "position_source"
  string display_name = 2;         // e.g., "Power Meter"
  string description = 3;
  string required_capability = 4;  // Capability device must have: "readable", "movable", etc.
  bool allows_multiple = 5;        // Can multiple devices fill this role?
}

// A configurable parameter for a module
message ModuleParameter {
  string param_id = 1;             // e.g., "threshold", "sample_rate"
  string display_name = 2;         // e.g., "Alert Threshold"
  string description = 3;
  string param_type = 4;           // "float", "int", "string", "bool", "enum"
  string default_value = 5;        // Default as string
  optional string min_value = 6;   // For numeric types
  optional string max_value = 7;   // For numeric types
  repeated string enum_values = 8; // For enum types
  string units = 9;                // e.g., "mW", "Hz", "ms"
  bool required = 10;
}

// --------------------------------------------------------------------------
// Module Lifecycle Messages
// --------------------------------------------------------------------------

message CreateModuleRequest {
  string type_id = 1;              // Module type to instantiate
  string instance_name = 2;        // User-friendly name for this instance
  map<string, string> initial_config = 3;  // Initial parameter values
}

message CreateModuleResponse {
  bool success = 1;
  string module_id = 2;            // Unique ID for this instance
  string error_message = 3;
}

message DeleteModuleRequest {
  string module_id = 1;
  bool force = 2;                  // If true, stop module first if running
}

message DeleteModuleResponse {
  bool success = 1;
  string error_message = 2;
}

message ListModulesRequest {
  optional string type_filter = 1;    // Filter by module type
  optional ModuleState state_filter = 2;  // Filter by state
}

message ListModulesResponse {
  repeated ModuleStatus modules = 1;
}

message GetModuleStatusRequest {
  string module_id = 1;
}

// Module execution state (lifecycle: Created → Configured → Staged → Running → Paused/Stopped/Error)
enum ModuleState {
  MODULE_STATE_UNSPECIFIED = 0;
  MODULE_CREATED = 1;       // Created but not configured
  MODULE_CONFIGURED = 2;    // Configured, ready to start
  MODULE_RUNNING = 3;       // Actively executing
  MODULE_PAUSED = 4;        // Paused
  MODULE_STOPPED = 5;       // Stopped by user
  MODULE_ERROR = 6;         // Error state
  MODULE_STAGED = 7;        // Resources allocated and ready to start
}

// Full status of a module instance
message ModuleStatus {
  string module_id = 1;
  string type_id = 2;
  string instance_name = 3;
  ModuleState state = 4;

  // Assignment status
  uint32 required_roles_filled = 10;
  uint32 required_roles_total = 11;
  bool ready_to_start = 12;        // Is module now ready to start?

  // Runtime info (when running)
  uint64 start_time_ns = 20;
  uint64 uptime_ns = 21;
  uint64 events_emitted = 22;
  uint64 data_points_produced = 23;

  // Error info (when in error state)
  string error_message = 30;
  uint64 error_time_ns = 31;
}

// --------------------------------------------------------------------------
// Module Configuration Messages
// --------------------------------------------------------------------------

message ConfigureModuleRequest {
  string module_id = 1;
  map<string, string> parameters = 2;  // Key-value pairs (values as strings)
  bool partial = 3;                    // If true, only update provided params
}

message ConfigureModuleResponse {
  bool success = 1;
  string error_message = 2;
  repeated string warnings = 3;        // Non-fatal config warnings
}

message GetModuleConfigRequest {
  string module_id = 1;
}

message ModuleConfig {
  string module_id = 1;
  string type_id = 2;
  map<string, string> parameters = 3;
  repeated DeviceAssignment assignments = 4;
}

// --------------------------------------------------------------------------
// Device Assignment Messages
// --------------------------------------------------------------------------

message AssignDeviceRequest {
  string module_id = 1;
  string role_id = 2;              // Role within the module
  string device_id = 3;            // Device to assign
}

message AssignDeviceResponse {
  bool success = 1;
  string error_message = 2;
  bool module_ready = 3;           // Is module now ready to start?
}

message UnassignDeviceRequest {
  string module_id = 1;
  string role_id = 2;
  optional string device_id = 3;   // If multiple devices in role, specify which
}

message UnassignDeviceResponse {
  bool success = 1;
  string error_message = 2;
}

message ListAssignmentsRequest {
  string module_id = 1;
}

message ListAssignmentsResponse {
  repeated DeviceAssignment assignments = 1;
}

// A device assigned to a role
message DeviceAssignment {
  string role_id = 1;
  string device_id = 2;
  string device_name = 3;          // For display
  bool device_online = 4;          // Is device currently accessible?
}

// --------------------------------------------------------------------------
// Module Execution Control Messages
// --------------------------------------------------------------------------

message StartModuleRequest {
  string module_id = 1;
}

message StartModuleResponse {
  bool success = 1;
  string error_message = 2;
  uint64 start_time_ns = 3;
}

message PauseModuleRequest {
  string module_id = 1;
}

message PauseModuleResponse {
  bool success = 1;
  string error_message = 2;
}

message ResumeModuleRequest {
  string module_id = 1;
}

message ResumeModuleResponse {
  bool success = 1;
  string error_message = 2;
}

message StopModuleRequest {
  string module_id = 1;
  bool force = 2;                  // If true, immediate stop; if false, graceful
}

message StopModuleResponse {
  bool success = 1;
  string error_message = 2;
  uint64 uptime_ns = 3;
  uint64 events_emitted = 4;
}

// --------------------------------------------------------------------------
// Module Event Streaming Messages
// --------------------------------------------------------------------------

message StreamModuleEventsRequest {
  string module_id = 1;
  repeated string event_types = 2;  // Filter by event type (empty = all)
}

// An event emitted by a module
message ModuleEvent {
  string module_id = 1;
  string event_type = 2;           // e.g., "threshold_exceeded", "state_change", "error"
  uint64 timestamp_ns = 3;
  ModuleEventSeverity severity = 4;
  string message = 5;
  map<string, string> data = 6;    // Event-specific data as key-value pairs
}

enum ModuleEventSeverity {
  MODULE_EVENT_SEVERITY_UNSPECIFIED = 0;
  INFO = 1;
  WARNING = 2;
  ERROR = 3;
  CRITICAL = 4;
}

message StreamModuleDataRequest {
  string module_id = 1;
  repeated string data_types = 2;  // Filter by data type (empty = all)
  uint32 max_rate_hz = 3;          // Rate limit for data stream
}

// A data point produced by a module
message ModuleDataPoint {
  string module_id = 1;
  string data_type = 2;            // e.g., "power_average", "position_error", "statistics"
  uint64 timestamp_ns = 3;
  map<string, double> values = 4;  // Named numeric values
  map<string, string> metadata = 5; // Additional metadata
}

// =============================================================================
// RunEngineService - Bluesky-style Plan Execution (Research-Informed)
// =============================================================================
//
// Separates experiment logic (Plans) from execution (RunEngine).
// Plans are declarative sequences that yield commands; the RunEngine executes them.
// This enables:
//   - Pause/Resume at safe checkpoints
//   - Structured metadata (Document Model)
//   - Clean separation of concerns
//
// Inspired by: Bluesky (NSLS-II), ophyd device abstraction

service RunEngineService {
  // ==========================================================================
  // Plan Management
  // ==========================================================================

  // List available plan types (LineScan, GridScan, TimeSeries, etc.)
  rpc ListPlanTypes(ListPlanTypesRequest) returns (ListPlanTypesResponse);

  // Get detailed info about a plan type
  rpc GetPlanTypeInfo(GetPlanTypeInfoRequest) returns (PlanTypeInfo);

  // ==========================================================================
  // Plan Execution
  // ==========================================================================

  // Queue a plan for execution
  rpc QueuePlan(QueuePlanRequest) returns (QueuePlanResponse);

  // Start executing queued plans (or resume if paused)
  rpc StartEngine(StartEngineRequest) returns (StartEngineResponse);

  // Pause at next checkpoint
  rpc PauseEngine(PauseEngineRequest) returns (PauseEngineResponse);

  // Resume from pause
  rpc ResumeEngine(ResumeEngineRequest) returns (ResumeEngineResponse);

  // Abort current plan (stops at next safe point)
  rpc AbortPlan(AbortPlanRequest) returns (AbortPlanResponse);

  // Halt immediately (emergency stop)
  rpc HaltEngine(HaltEngineRequest) returns (HaltEngineResponse);

  // Get engine status
  rpc GetEngineStatus(GetEngineStatusRequest) returns (EngineStatus);

  // ==========================================================================
  // Document Streaming (Bluesky Pattern)
  // ==========================================================================

  // Stream documents from plan execution
  rpc StreamDocuments(StreamDocumentsRequest) returns (stream Document);
}

// --------------------------------------------------------------------------
// Plan Type Discovery
// --------------------------------------------------------------------------

message ListPlanTypesRequest {
  // Empty for now
}

message ListPlanTypesResponse {
  repeated PlanTypeSummary plan_types = 1;
}

message PlanTypeSummary {
  string type_id = 1;           // e.g., "line_scan", "grid_scan", "time_series"
  string display_name = 2;      // e.g., "Line Scan"
  string description = 3;
  repeated string categories = 4;  // e.g., ["scanning", "1d"]
}

message GetPlanTypeInfoRequest {
  string type_id = 1;
}

message PlanTypeInfo {
  string type_id = 1;
  string display_name = 2;
  string description = 3;

  // Required parameters
  repeated PlanParameter parameters = 10;

  // Required device roles
  repeated PlanDeviceRole device_roles = 20;
}

// A parameter for configuring a plan
message PlanParameter {
  string param_id = 1;
  string display_name = 2;
  string description = 3;
  string dtype = 4;             // "float", "int", "string", "device_id"
  string default_value = 5;
  bool required = 6;
  optional string min_value = 7;
  optional string max_value = 8;
  string units = 9;
}

// A device role required by a plan
message PlanDeviceRole {
  string role_id = 1;           // e.g., "motor", "detector"
  string required_capability = 2;  // "movable", "readable", etc.
  string description = 3;
}

// --------------------------------------------------------------------------
// Plan Execution Messages
// --------------------------------------------------------------------------

message QueuePlanRequest {
  string plan_type = 1;
  map<string, string> parameters = 2;      // Plan configuration
  map<string, string> device_mapping = 3;  // role_id -> device_id
  map<string, string> metadata = 4;        // User-provided metadata
}

message QueuePlanResponse {
  bool success = 1;
  string run_uid = 2;           // Unique ID for this run
  string error_message = 3;
  uint32 queue_position = 4;
}

message StartEngineRequest {
  // Empty - starts processing queue
}

message StartEngineResponse {
  bool success = 1;
  string error_message = 2;
}

message PauseEngineRequest {
  bool defer = 1;               // If true, pause at next checkpoint; if false, immediate
}

message PauseEngineResponse {
  bool success = 1;
  string paused_at = 2;         // Description of pause point
}

message ResumeEngineRequest {
  // Empty
}

message ResumeEngineResponse {
  bool success = 1;
  string error_message = 2;
}

message AbortPlanRequest {
  string run_uid = 1;           // Which run to abort (empty = current)
}

message AbortPlanResponse {
  bool success = 1;
  string error_message = 2;
}

message HaltEngineRequest {
  // Empty - emergency stop
}

message HaltEngineResponse {
  bool halted = 1;
  string message = 2;
}

message GetEngineStatusRequest {
  // Empty
}

// Engine execution state
enum EngineState {
  ENGINE_STATE_UNSPECIFIED = 0;
  ENGINE_IDLE = 1;              // No plans running
  ENGINE_RUNNING = 2;           // Executing a plan
  ENGINE_PAUSED = 3;            // Paused at checkpoint
  ENGINE_ABORTING = 4;          // Abort in progress
  ENGINE_HALTED = 5;            // Emergency halt
}

message EngineStatus {
  EngineState state = 1;

  // Current run info (if running/paused)
  optional string current_run_uid = 10;
  optional string current_plan_type = 11;
  optional uint32 current_event_number = 12;
  optional uint32 total_events_expected = 13;

  // Queue info
  uint32 queued_plans = 20;

  // Timing
  uint64 run_start_ns = 30;
  uint64 elapsed_ns = 31;
}

// --------------------------------------------------------------------------
// Document Model (Bluesky Pattern)
// --------------------------------------------------------------------------

// Document types for structured experiment data
enum DocumentType {
  DOC_TYPE_UNSPECIFIED = 0;
  DOC_START = 1;                // Experiment intent and metadata
  DOC_DESCRIPTOR = 2;           // Schema for data streams
  DOC_EVENT = 3;                // Actual measurements
  DOC_STOP = 4;                 // Completion status
}

message Document {
  DocumentType doc_type = 1;
  string uid = 2;               // Unique document ID
  uint64 timestamp_ns = 3;

  oneof payload {
    StartDocument start = 10;
    DescriptorDocument descriptor = 11;
    EventDocument event = 12;
    StopDocument stop = 13;
  }
}

// Start document - emitted at beginning of a run
message StartDocument {
  string run_uid = 1;           // Unique run identifier
  string plan_type = 2;
  string plan_name = 3;         // User-friendly name
  map<string, string> plan_args = 4;
  map<string, string> metadata = 5;
  repeated string hints = 6;    // Visualization hints
  uint64 time_ns = 7;
}

// Descriptor document - defines schema for event data
message DescriptorDocument {
  string run_uid = 1;           // Links to StartDocument
  string descriptor_uid = 2;
  string name = 3;              // e.g., "primary", "baseline"
  map<string, DataKey> data_keys = 4;
  map<string, string> configuration = 5;
}

// Schema for a data field
message DataKey {
  string dtype = 1;             // "number", "array", "string"
  repeated int32 shape = 2;     // For arrays, e.g., [2048, 2048]
  string source = 3;            // Device ID
  string units = 4;
  optional double precision = 5;
}

// Event document - actual measurement data
message EventDocument {
  string descriptor_uid = 1;    // Links to DescriptorDocument
  uint32 seq_num = 2;           // Event sequence number
  uint64 time_ns = 3;

  // Scalar data (embedded)
  map<string, double> data = 10;
  map<string, uint64> timestamps = 11;  // Per-field timestamps

  // Bulk data references (use Arrow Flight to retrieve)
  map<string, FlightTicket> bulk_data = 20;

  // === Middle-data support (bd-9unn) ===
  // For status messages, enum states, and small text values
  map<string, string> metadata = 30;

  // For small arrays (spectra, waveforms up to ~64KB) without Arrow Flight overhead
  // Format: msgpack-encoded arrays, JSON arrays, or raw binary with schema in metadata
  map<string, bytes> arrays = 31;
}

// Stop document - emitted at end of a run
message StopDocument {
  string run_uid = 1;           // Links to StartDocument
  string exit_status = 2;       // "success", "abort", "fail"
  string reason = 3;            // If abort/fail, why
  uint64 time_ns = 4;
  uint32 num_events = 5;
}

message StreamDocumentsRequest {
  optional string run_uid = 1;  // Filter by run (empty = all)
  repeated DocumentType doc_types = 2;  // Filter by type (empty = all)
}

// =============================================================================
// StorageService - HDF5 Data Storage and Export (bd-p6im)
// =============================================================================
//
// Provides persistent storage for acquired data using HDF5 format.
// Uses the "Mullet Strategy": Arrow for fast in-memory processing,
// HDF5 for long-term storage and cross-platform compatibility.
//
// Key features:
//   - Configure output directory and HDF5 settings
//   - Start/Stop data recording
//   - List and query stored acquisitions
//   - Export data from ring buffer to HDF5 files
//   - Background flushing at configurable intervals
//
// Example workflow:
//   1. ConfigureStorage(output_dir="/data/experiments", compression="gzip")
//   2. StartRecording(name="my_experiment") - begins capturing ring buffer
//   3. ... acquire data via ScanService or RunEngineService ...
//   4. StopRecording() - finalizes HDF5 file
//   5. ListAcquisitions() - see saved files
//   6. GetAcquisitionInfo(acquisition_id) - get file metadata

service StorageService {
  // ==========================================================================
  // Storage Configuration
  // ==========================================================================

  // Configure storage settings (output directory, format options)
  rpc ConfigureStorage(ConfigureStorageRequest) returns (ConfigureStorageResponse);

  // Get current storage configuration
  rpc GetStorageConfig(GetStorageConfigRequest) returns (StorageConfig);

  // ==========================================================================
  // Recording Control
  // ==========================================================================

  // Start recording data to HDF5 file
  rpc StartRecording(StartRecordingRequest) returns (StartRecordingResponse);

  // Stop recording and finalize HDF5 file
  rpc StopRecording(StopRecordingRequest) returns (StopRecordingResponse);

  // Get current recording status
  rpc GetRecordingStatus(GetRecordingStatusRequest) returns (RecordingStatus);

  // ==========================================================================
  // Acquisition Management
  // ==========================================================================

  // List all saved acquisitions (HDF5 files)
  rpc ListAcquisitions(ListAcquisitionsRequest) returns (ListAcquisitionsResponse);

  // Get detailed info about a specific acquisition
  rpc GetAcquisitionInfo(GetAcquisitionInfoRequest) returns (AcquisitionInfo);

  // Delete an acquisition file
  rpc DeleteAcquisition(DeleteAcquisitionRequest) returns (DeleteAcquisitionResponse);

  // ==========================================================================
  // Data Export
  // ==========================================================================

  // Export ring buffer data to HDF5 (manual flush)
  rpc FlushToStorage(FlushToStorageRequest) returns (FlushToStorageResponse);

  // Stream recording progress updates
  rpc StreamRecordingProgress(StreamRecordingProgressRequest) returns (stream RecordingProgress);

  // ==========================================================================
  // Ring Buffer Tap (Cross-Process Access)
  // ==========================================================================

  // Get information for cross-process ring buffer access via mmap.
  // Python/Julia clients can use this to discover the buffer location and
  // parameters needed to safely read data without gRPC overhead.
  rpc GetRingBufferTapInfo(GetRingBufferTapInfoRequest) returns (RingBufferTapInfo);
}

// --------------------------------------------------------------------------
// Storage Configuration Messages
// --------------------------------------------------------------------------

message ConfigureStorageRequest {
  // Output directory for HDF5 files
  string output_directory = 1;

  // HDF5-specific settings
  HDF5Config hdf5_config = 2;

  // Ring buffer flush settings
  optional uint32 flush_interval_ms = 3;  // How often to flush (default: 1000ms)
  optional uint32 max_buffer_mb = 4;      // Max memory before forced flush
}

message HDF5Config {
  // Compression settings
  string compression = 1;                 // "none", "gzip", "lz4", "zstd"
  optional uint32 compression_level = 2;  // 1-9 for gzip, varies by algorithm

  // Chunking settings
  optional uint32 chunk_size = 3;         // Chunk size for datasets (default: 4096)

  // File naming pattern
  optional string filename_pattern = 4;   // e.g., "{name}_{timestamp}.h5"

  // Metadata options
  bool include_timestamps = 5;            // Store per-sample timestamps
  bool include_device_metadata = 6;       // Store device configuration
}

message ConfigureStorageResponse {
  bool success = 1;
  string error_message = 2;
  string resolved_output_directory = 3;   // Absolute path after resolution
}

message GetStorageConfigRequest {
  // Empty
}

message StorageConfig {
  string output_directory = 1;
  HDF5Config hdf5_config = 2;
  uint32 flush_interval_ms = 3;
  uint32 max_buffer_mb = 4;

  // Status info
  uint64 disk_space_available_bytes = 10;
  uint64 disk_space_used_bytes = 11;
}

// --------------------------------------------------------------------------
// Recording Control Messages
// --------------------------------------------------------------------------

message StartRecordingRequest {
  // Recording name (used in filename)
  string name = 1;

  // Optional metadata to embed in HDF5 file
  map<string, string> metadata = 2;

  // Optional: override default config for this recording
  optional HDF5Config config_override = 3;

  // Optional: associate with a scan or run
  optional string scan_id = 10;
  optional string run_uid = 11;
}

message StartRecordingResponse {
  bool success = 1;
  string error_message = 2;
  string recording_id = 3;           // Unique ID for this recording session
  string output_path = 4;            // Full path to HDF5 file being written
}

message StopRecordingRequest {
  optional string recording_id = 1;  // If omitted, stops current recording

  // Final metadata to add
  map<string, string> final_metadata = 2;
}

message StopRecordingResponse {
  bool success = 1;
  string error_message = 2;
  string acquisition_id = 3;         // ID to reference the completed file
  string output_path = 4;            // Full path to finalized HDF5 file
  uint64 file_size_bytes = 5;
  uint64 total_samples = 6;
  uint64 duration_ns = 7;
}

message GetRecordingStatusRequest {
  optional string recording_id = 1;  // If omitted, returns current recording
}

// Recording state
enum RecordingState {
  RECORDING_STATE_UNSPECIFIED = 0;
  RECORDING_IDLE = 1;                // No active recording
  RECORDING_ACTIVE = 2;              // Actively recording
  RECORDING_FLUSHING = 3;            // Flushing buffer to disk
  RECORDING_FINALIZING = 4;          // Closing HDF5 file
  RECORDING_ERROR = 5;               // Error during recording
}

message RecordingStatus {
  string recording_id = 1;
  RecordingState state = 2;
  string output_path = 3;

  // Progress info
  uint64 samples_recorded = 10;
  uint64 bytes_written = 11;
  uint64 start_time_ns = 12;
  uint64 elapsed_ns = 13;

  // Buffer status
  uint32 buffer_fill_percent = 20;
  uint64 pending_samples = 21;
  uint64 flushes_completed = 22;

  // Error info (if state == RECORDING_ERROR)
  string error_message = 30;
}

// --------------------------------------------------------------------------
// Acquisition Management Messages
// --------------------------------------------------------------------------

message ListAcquisitionsRequest {
  // Optional filters
  optional string name_pattern = 1;       // Glob pattern for name matching
  optional uint64 after_timestamp_ns = 2; // Only files created after
  optional uint64 before_timestamp_ns = 3;// Only files created before
  optional uint32 limit = 4;              // Max results (default: 100)
  optional uint32 offset = 5;             // For pagination
}

message ListAcquisitionsResponse {
  repeated AcquisitionSummary acquisitions = 1;
  uint32 total_count = 2;                 // Total matching (for pagination)
}

// Brief summary of an acquisition
message AcquisitionSummary {
  string acquisition_id = 1;
  string name = 2;
  string file_path = 3;
  uint64 file_size_bytes = 4;
  uint64 created_at_ns = 5;
  uint64 duration_ns = 6;
  uint64 sample_count = 7;
}

message GetAcquisitionInfoRequest {
  string acquisition_id = 1;
}

// Detailed acquisition information
message AcquisitionInfo {
  string acquisition_id = 1;
  string name = 2;
  string file_path = 3;
  uint64 file_size_bytes = 4;
  uint64 created_at_ns = 5;
  uint64 duration_ns = 6;

  // Data structure info
  repeated DatasetInfo datasets = 10;

  // Embedded metadata
  map<string, string> metadata = 20;

  // Associated scan/run (if any)
  optional string scan_id = 30;
  optional string run_uid = 31;

  // HDF5 file structure summary
  HDF5Structure structure = 40;
}

// Information about a dataset within the HDF5 file
message DatasetInfo {
  string name = 1;                        // Dataset path, e.g., "/data/power"
  string dtype = 2;                       // Data type, e.g., "float64", "uint16"
  repeated uint64 shape = 3;              // Dataset shape
  string units = 4;                       // Physical units
  string device_id = 5;                   // Source device
  uint64 sample_count = 6;                // Number of samples
  optional double min_value = 7;          // Data range (if computed)
  optional double max_value = 8;
}

// HDF5 file structure summary
message HDF5Structure {
  repeated string groups = 1;             // Group paths
  uint32 dataset_count = 2;
  uint64 total_elements = 3;
  string compression = 4;
  uint32 chunk_size = 5;
}

message DeleteAcquisitionRequest {
  string acquisition_id = 1;
  bool confirm = 2;                       // Must be true to actually delete
}

message DeleteAcquisitionResponse {
  bool success = 1;
  string error_message = 2;
  uint64 bytes_freed = 3;
}

// --------------------------------------------------------------------------
// Data Export Messages
// --------------------------------------------------------------------------

message FlushToStorageRequest {
  optional string recording_id = 1;       // If omitted, flushes current
  bool sync = 2;                          // If true, wait for flush to complete
}

message FlushToStorageResponse {
  bool success = 1;
  string error_message = 2;
  uint64 samples_flushed = 3;
  uint64 bytes_written = 4;
}

message StreamRecordingProgressRequest {
  string scan_id = 1;
  uint32 update_interval_ms = 2;          // How often to send updates (default: 500)
}

message RecordingProgress {
  string scan_id = 1;
  ScanState state = 2;
  uint64 timestamp_ns = 3;

  // Incremental progress
  uint64 samples_recorded = 10;
  uint64 bytes_written = 11;
  double samples_per_second = 12;         // Current throughput

  // Buffer status
  uint32 buffer_fill_percent = 20;
  bool flush_in_progress = 21;

  // Estimated time remaining (if deterministic)
  optional uint64 estimated_remaining_ns = 30;
}

// --------------------------------------------------------------------------
// Ring Buffer Tap Messages (bd-vms4.2)
// --------------------------------------------------------------------------

// Request for ring buffer tap information
message GetRingBufferTapInfoRequest {
  // Optional: specific buffer name (empty = default/primary buffer)
  string buffer_name = 1;
}

// Information for cross-process ring buffer access via mmap.
// Contains all parameters needed for Python/Julia to safely read the buffer.
message RingBufferTapInfo {
  // Filesystem path to the memory-mapped buffer file
  // (e.g., "/dev/shm/rust_daq_ring.buf" or "/tmp/rust_daq_ring.buf")
  string file_path = 1;

  // Total size of the file in bytes (header + data region)
  uint64 total_size_bytes = 2;

  // Size of the data region in bytes (excluding header)
  uint64 capacity_bytes = 3;

  // Header size in bytes (fixed at 128 bytes, but included for forward compat)
  uint32 header_size = 4;

  // Current stream ID for detecting buffer re-initialization.
  // If this value changes, readers should re-open the buffer.
  uint64 stream_id = 5;

  // Magic number for validation (0xDADADADA00000001)
  uint64 magic = 6;

  // Current write head position (total bytes written, monotonically increasing)
  uint64 write_head = 10;

  // Current read tail position (oldest unconsumed data)
  uint64 read_tail = 11;

  // Current write epoch (for seqlock synchronization)
  uint64 write_epoch = 12;

  // Data format information
  string data_format = 20;           // "arrow_ipc", "raw", etc.
  optional string arrow_schema_json = 21;  // Arrow schema if applicable
}

// =============================================================================
// PluginService - Data-driven instrument plugin management (bd-22si.6.1)
// =============================================================================
//
// Exposes plugin metadata for dynamic UI rendering and plugin management.
// Plugins are YAML-defined instrument drivers that can be loaded at runtime.
//
// Key features:
//   - List available plugins and their capabilities
//   - Get detailed plugin configuration for UI generation
//   - Spawn plugin instances with custom addresses
//   - Query plugin instances for current state
//
// Example workflow:
//   1. ListPlugins() - see available plugin types
//   2. GetPluginInfo("maitai-laser") - get capabilities and UI hints
//   3. SpawnPlugin("maitai-laser", "/dev/ttyUSB0") - instantiate driver
//   4. Use HardwareService to control the spawned device

service PluginService {
  // ==========================================================================
  // Plugin Discovery
  // ==========================================================================

  // List all available plugin types
  rpc ListPlugins(ListPluginsRequest) returns (ListPluginsResponse);

  // Get detailed info about a specific plugin type
  rpc GetPluginInfo(GetPluginInfoRequest) returns (PluginInfo);

  // ==========================================================================
  // Plugin Instance Management
  // ==========================================================================

  // Spawn a new plugin instance
  rpc SpawnPlugin(SpawnPluginRequest) returns (SpawnPluginResponse);

  // List all spawned plugin instances
  rpc ListPluginInstances(ListPluginInstancesRequest) returns (ListPluginInstancesResponse);

  // Get status of a specific plugin instance
  rpc GetPluginInstanceStatus(GetPluginInstanceStatusRequest) returns (PluginInstanceStatus);

  // Destroy a plugin instance
  rpc DestroyPluginInstance(DestroyPluginInstanceRequest) returns (DestroyPluginInstanceResponse);
}

// --------------------------------------------------------------------------
// Plugin Discovery Messages
// --------------------------------------------------------------------------

message ListPluginsRequest {
  // Optional filter by driver type
  optional string driver_type_filter = 1;  // "serial_scpi", "tcp_scpi", etc.
}

message ListPluginsResponse {
  repeated PluginSummary plugins = 1;
}

// Brief summary of a plugin
message PluginSummary {
  string plugin_id = 1;           // Unique plugin ID from YAML metadata.id
  string name = 2;                // Display name from YAML metadata.name
  string version = 3;             // Plugin version
  string driver_type = 4;         // "serial_scpi", "tcp_scpi", "serial_raw", "tcp_raw"

  // Capability flags (quick check without fetching full info)
  bool has_readable = 10;
  bool has_movable = 11;
  bool has_settable = 12;
  bool has_switchable = 13;
  bool has_actionable = 14;
  bool has_loggable = 15;
  bool has_scriptable = 16;
}

message GetPluginInfoRequest {
  string plugin_id = 1;
}

// Full plugin information for UI generation
message PluginInfo {
  // Metadata
  string plugin_id = 1;
  string name = 2;
  string version = 3;
  string driver_type = 4;

  // Protocol configuration
  PluginProtocol protocol = 10;

  // Capabilities (detailed)
  PluginCapabilities capabilities = 20;

  // UI layout hints from YAML
  repeated PluginUIElement ui_layout = 30;
}

// Protocol settings from plugin YAML
message PluginProtocol {
  uint32 baud_rate = 1;           // For serial connections
  string termination = 2;         // Line terminator
  uint32 command_delay_ms = 3;    // Delay after commands
  uint32 timeout_ms = 4;          // Read timeout

  // TCP settings (for tcp_* driver types)
  optional string tcp_host = 10;
  optional uint32 tcp_port = 11;
}

// All capabilities from plugin YAML
message PluginCapabilities {
  repeated PluginReadable readable = 1;
  optional PluginMovable movable = 2;
  repeated PluginSettable settable = 3;
  repeated PluginSwitchable switchable = 4;
  repeated PluginActionable actionable = 5;
  repeated PluginLoggable loggable = 6;
  repeated PluginScriptable scriptable = 7;
}

// Readable capability (sensor values)
message PluginReadable {
  string name = 1;
  string command = 2;             // Command to send
  string pattern = 3;             // Response parsing pattern
  optional string unit = 4;
}

// Movable capability (motion control)
message PluginMovable {
  repeated PluginAxis axes = 1;
  string set_cmd = 2;             // Move command template
  string get_cmd = 3;             // Position query template
  string get_pattern = 4;         // Position response pattern
}

// Axis configuration
message PluginAxis {
  string name = 1;
  optional string unit = 2;
  optional double min = 3;
  optional double max = 4;
}

// Settable capability (parameters)
message PluginSettable {
  string name = 1;
  string set_cmd = 2;
  optional string get_cmd = 3;
  string pattern = 4;
  optional string unit = 5;
  optional double min = 6;
  optional double max = 7;
  string value_type = 8;          // "float", "int", "string", "enum", "bool"
  repeated string options = 9;    // For enum types
}

// Switchable capability (on/off)
message PluginSwitchable {
  string name = 1;
  string on_cmd = 2;
  string off_cmd = 3;
  optional string status_cmd = 4;
  optional string pattern = 5;
}

// Actionable capability (one-shot commands)
message PluginActionable {
  string name = 1;
  string cmd = 2;
  uint32 wait_ms = 3;
}

// Loggable capability (static metadata)
message PluginLoggable {
  string name = 1;
  string cmd = 2;
  string pattern = 3;
}

// Scriptable capability (Rhai scripts)
message PluginScriptable {
  string name = 1;
  optional string description = 2;
  string script = 3;              // Rhai script source
  uint32 timeout_ms = 4;
}

// UI layout element from plugin YAML
message PluginUIElement {
  string element_type = 1;        // "group", "slider", "readout", "toggle", "button", "dropdown"
  string label = 2;
  optional string target = 3;     // Links to capability name
  optional string source = 4;     // For readout, links to readable
  optional string action = 5;     // For button, links to actionable
  repeated PluginUIElement children = 10;  // For group elements
}

// --------------------------------------------------------------------------
// Plugin Instance Management Messages
// --------------------------------------------------------------------------

message SpawnPluginRequest {
  string plugin_id = 1;
  string address = 2;             // Port path or "host:port" for TCP
  optional string instance_name = 3;  // Optional friendly name
  bool mock_mode = 4;             // If true, use mock data instead of real communication
}

message SpawnPluginResponse {
  bool success = 1;
  string error_message = 2;
  string instance_id = 3;         // Unique ID for this instance
  string device_id = 4;           // Device ID registered with HardwareService
}

message ListPluginInstancesRequest {
  optional string plugin_id = 1;  // Filter by plugin type
}

message ListPluginInstancesResponse {
  repeated PluginInstanceSummary instances = 1;
}

message PluginInstanceSummary {
  string instance_id = 1;
  string plugin_id = 2;
  string plugin_name = 3;
  string address = 4;
  string device_id = 5;
  bool connected = 6;
  bool mock_mode = 7;
}

message GetPluginInstanceStatusRequest {
  string instance_id = 1;
}

message PluginInstanceStatus {
  string instance_id = 1;
  string plugin_id = 2;
  string plugin_name = 3;
  string address = 4;
  string device_id = 5;
  bool connected = 6;
  bool mock_mode = 7;

  // Last error (if any)
  optional string last_error = 10;
  optional uint64 last_error_time_ns = 11;

  // Statistics
  uint64 commands_sent = 20;
  uint64 commands_failed = 21;
  uint64 uptime_ns = 22;
}

message DestroyPluginInstanceRequest {
  string instance_id = 1;
  bool run_disconnect_sequence = 2;  // Execute on_disconnect commands first
}

message DestroyPluginInstanceResponse {
  bool success = 1;
  string error_message = 2;
}

// ==========================================================================
// HEALTH MONITORING SERVICE (bd-pauy)
// System health monitoring for headless operation
// ==========================================================================

service HealthService {
  // Get overall system health status
  rpc GetSystemHealth(GetSystemHealthRequest) returns (GetSystemHealthResponse);

  // Get detailed health status for all modules
  rpc GetModuleHealth(GetModuleHealthRequest) returns (GetModuleHealthResponse);

  // Get recent error history
  rpc GetErrorHistory(GetErrorHistoryRequest) returns (GetErrorHistoryResponse);

  // Stream health updates in real-time
  rpc StreamHealthUpdates(StreamHealthUpdatesRequest) returns (stream HealthUpdate);
}

// Request for system health
message GetSystemHealthRequest {}

// Response with overall system health
message GetSystemHealthResponse {
  SystemHealthStatus status = 1;
  uint32 total_modules = 2;
  uint32 healthy_modules = 3;
  uint32 unhealthy_modules = 4;
  uint32 total_errors = 5;
  uint32 critical_errors = 6;
  uint64 timestamp_ns = 7;
}

// Overall system health status
enum SystemHealthStatus {
  SYSTEM_HEALTH_UNKNOWN = 0;
  SYSTEM_HEALTH_HEALTHY = 1;
  SYSTEM_HEALTH_DEGRADED = 2;
  SYSTEM_HEALTH_CRITICAL = 3;
}

// Request for module health details
message GetModuleHealthRequest {}

// Response with per-module health status
message GetModuleHealthResponse {
  repeated ModuleHealthStatus modules = 1;
  uint64 timestamp_ns = 2;
}

// Health status for a single module
message ModuleHealthStatus {
  string name = 1;
  bool is_healthy = 2;
  uint64 last_heartbeat_ns = 3;
  uint64 seconds_since_heartbeat = 4;
  optional string status_message = 5;
}

// Request for error history
message GetErrorHistoryRequest {
  optional uint32 limit = 1;           // Max errors to return (default: 100)
  optional string module_name = 2;     // Filter by module name
  optional ErrorSeverityLevel min_severity = 3;  // Filter by severity
}

// Response with error history
message GetErrorHistoryResponse {
  repeated HealthErrorRecord errors = 1;
  uint32 total_error_count = 2;
  uint64 timestamp_ns = 3;
}

// A single health error record
message HealthErrorRecord {
  string module_name = 1;
  ErrorSeverityLevel severity = 2;
  string message = 3;
  uint64 timestamp_ns = 4;
  map<string, string> context = 5;
}

// Error severity levels
enum ErrorSeverityLevel {
  ERROR_SEVERITY_UNKNOWN = 0;
  ERROR_SEVERITY_INFO = 1;
  ERROR_SEVERITY_WARNING = 2;
  ERROR_SEVERITY_ERROR = 3;
  ERROR_SEVERITY_CRITICAL = 4;
}

// Request to stream health updates
message StreamHealthUpdatesRequest {
  uint32 update_interval_ms = 1;  // How often to send updates (default: 5000ms)
}

// Real-time health update
message HealthUpdate {
  SystemHealthStatus system_status = 1;
  repeated ModuleHealthStatus modules = 2;
  optional HealthErrorRecord latest_error = 3;
  uint64 timestamp_ns = 4;
}
