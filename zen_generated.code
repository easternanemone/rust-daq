<GENERATED-CODE>
I will provide a new file, `src/mock_serial.rs`, containing the full implementation for the mock serial port and its test harness. I will also provide an example test file, `tests/device_comm_test.rs`, to demonstrate its usage.

1.  Create `src/mock_serial.rs` to define the `MockSerialPort` and `MockDeviceHarness`.
2.  Create `tests/device_comm_test.rs` to show a practical example of how to use these mocks for testing application logic.

<NEWFILE: src/mock_serial.rs>
```rust
//! A mock serial port implementation for testing async serial communication.
//!
//! This module provides `MockSerialPort` which implements `AsyncRead` and `AsyncWrite`,
//! and a corresponding `MockDeviceHarness` to control the mock from within tests.
//! This allows for simulating device interactions, including command/response sequences,
//! delays, and timeouts.

use std::collections::VecDeque;
use std::io;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::io::{AsyncRead, AsyncWrite, ReadBuf};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};

/// The client-facing side of the mock serial port.
///
/// This struct implements `AsyncRead` and `AsyncWrite` and is intended to be
/// passed to the application code under test as a drop-in replacement for a
/// real `serial2_tokio::SerialPort`.
#[derive(Debug)]
pub struct MockSerialPort {
    // Channel to send written data to the harness.
    writes_tx: UnboundedSender<Vec<u8>>,
    // Channel to receive data from the harness to be read.
    reads_rx: UnboundedReceiver<Vec<u8>>,
    // Buffer for data received from the harness but not yet read by the client.
    read_buffer: VecDeque<u8>,
}

/// The test-facing side for controlling the mock serial port.
///
/// This harness allows a test to assert on data written by the client
/// and to send data back as if it were a real device.
#[derive(Debug)]
pub struct MockDeviceHarness {
    // Channel to receive data written by the client.
    writes_rx: UnboundedReceiver<Vec<u8>>,
    // Channel to send data to the client for it to read.
    reads_tx: UnboundedSender<Vec<u8>>,
    // Buffer for data received from the client but not yet asserted by the test.
    write_buffer: Vec<u8>,
}

/// Creates a new connected pair of `MockSerialPort` and `MockDeviceHarness`.
pub fn new() -> (MockSerialPort, MockDeviceHarness) {
    let (client_to_harness_tx, client_to_harness_rx) = mpsc::unbounded_channel();
    let (harness_to_client_tx, harness_to_client_rx) = mpsc::unbounded_channel();

    let port = MockSerialPort {
        writes_tx: client_to_harness_tx,
        reads_rx: harness_to_client_rx,
        read_buffer: VecDeque::new(),
    };

    let harness = MockDeviceHarness {
        writes_rx: client_to_harness_rx,
        reads_tx: harness_to_client_tx,
        write_buffer: Vec::new(),
    };

    (port, harness)
}

// --- MockSerialPort Implementations ---

impl AsyncRead for MockSerialPort {
    fn poll_read(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf<'_>,
    ) -> Poll<io::Result<()>> {
        // If we have data in our internal buffer, use that first.
        if !self.read_buffer.is_empty() {
            let available = self.read_buffer.len();
            let to_read = std::cmp::min(buf.remaining(), available);
            let chunk: Vec<u8> = self.read_buffer.drain(..to_read).collect();
            buf.put_slice(&chunk);
            return Poll::Ready(Ok(()));
        }

        // Otherwise, poll the channel for a new chunk of data from the harness.
        match self.reads_rx.poll_recv(cx) {
            Poll::Ready(Some(chunk)) => {
                // The harness sent data. Buffer it and then fill the user's buffer.
                self.read_buffer.extend(chunk);
                let available = self.read_buffer.len();
                let to_read = std::cmp::min(buf.remaining(), available);
                let data_to_put: Vec<u8> = self.read_buffer.drain(..to_read).collect();
                buf.put_slice(&data_to_put);
                Poll::Ready(Ok(()))
            }
            Poll::Ready(None) => {
                // Channel closed, which means end-of-file.
                Poll::Ready(Ok(()))
            }
            Poll::Pending => Poll::Pending,
        }
    }
}

impl AsyncWrite for MockSerialPort {
    fn poll_write(
        self: Pin<&mut Self>,
        _cx: &mut Context<'_>,
        buf: &[u8],
    ) -> Poll<io::Result<usize>> {
        match self.writes_tx.send(buf.to_vec()) {
            Ok(_) => Poll::Ready(Ok(buf.len())),
            Err(_) => {
                // The receiving end (harness) was dropped.
                Poll::Ready(Err(io::Error::new(
                    io::ErrorKind::BrokenPipe,
                    "mock device harness disconnected",
                )))
            }
        }
    }

    fn poll_flush(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> {
        // No-op for this mock.
        Poll::Ready(Ok(()))
    }

    fn poll_shutdown(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> {
        // No-op for this mock.
        Poll::Ready(Ok(()))
    }
}

// --- MockDeviceHarness Implementations ---

impl MockDeviceHarness {
    /// Sends a response to the client.
    ///
    /// This simulates the device sending data over the serial port.
    pub fn send_response(&self, data: &[u8]) -> Result<(), &'static str> {
        self.reads_tx
            .send(data.to_vec())
            .map_err(|_| "Failed to send response: client port disconnected")
    }

    /// Waits for the client to write specific data and asserts its correctness.
    ///
    /// This will buffer incoming writes until the expected sequence is received.
    /// It includes a timeout to prevent tests from hanging indefinitely.
    pub async fn expect_write(&mut self, expected: &[u8]) {
        use tokio::time::{timeout, Duration};

        let timeout_duration = Duration::from_secs(2); // Generous timeout for tests.

        while self.write_buffer.len() < expected.len() {
            match timeout(timeout_duration, self.writes_rx.recv()).await {
                Ok(Some(chunk)) => self.write_buffer.extend_from_slice(&chunk),
                Ok(None) => panic!("Client-side port closed while expecting a write."),
                Err(_) => {
                    panic!(
                        "Timeout waiting for write. Expected `{:?}` ({} bytes), but only received `{:?}` ({} bytes).",
                        String::from_utf8_lossy(expected),
                        expected.len(),
                        String::from_utf8_lossy(&self.write_buffer),
                        self.write_buffer.len()
                    );
                }
            }
        }

        let actual = &self.write_buffer[..expected.len()];
        assert_eq!(
            actual,
            expected,
            "Mismatch in expected write. Expected `{:?}`, got `{:?}`.",
            String::from_utf8_lossy(expected),
            String::from_utf8_lossy(actual)
        );

        // Remove the asserted data from the buffer, keeping any excess for the next expectation.
        self.write_buffer.drain(..expected.len());
    }
}
```
</NEWFILE>

<NEWFILE: tests/device_comm_test.rs>
```rust
// This file assumes `mock_serial` is available, e.g., in `src/mock_serial.rs`
// and your crate is named `my_project`.
// Add `mod mock_serial;` to your `src/lib.rs` or `src/main.rs` to make it accessible.
use my_project::mock_serial;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::time::{timeout, Duration};

// --- Example Application Logic to be Tested ---

/// A simple device client that sends a command and expects a response.
struct DeviceClient<T: AsyncRead + AsyncWrite + Unpin> {
    port: BufReader<T>,
}

impl<T: AsyncRead + AsyncWrite + Unpin> DeviceClient<T> {
    fn new(port: T) -> Self {
        Self {
            port: BufReader::new(port),
        }
    }

    /// Sends a "GET_STATUS" command and reads the response.
    async fn get_status(&mut self) -> Result<String, std::io::Error> {
        self.port.write_all(b"GET_STATUS\n").await?;

        let mut response = String::new();
        self.port.read_line(&mut response).await?;
        Ok(response)
    }
}

// --- Tests Using the Mock Harness ---

#[tokio::test]
async fn test_get_status_success() {
    let (port, mut harness) = mock_serial::new();
    let mut client = DeviceClient::new(port);

    // Spawn the client logic in a separate task.
    let client_task = tokio::spawn(async move {
        client.get_status().await.unwrap()
    });

    // Use the harness to drive the test.
    harness.expect_write(b"GET_STATUS\n").await;
    harness.send_response(b"STATUS_OK\n").unwrap();

    // Await the result and assert.
    let response = client_task.await.unwrap();
    assert_eq!(response, "STATUS_OK\n");
}

#[tokio::test]
async fn test_get_status_timeout() {
    let (port, mut harness) = mock_serial::new();
    let mut client = DeviceClient::new(port);

    // The client logic is wrapped in a timeout.
    let client_task = tokio::spawn(async move {
        timeout(Duration::from_millis(100), client.get_status()).await
    });

    // Harness expects the command...
    harness.expect_write(b"GET_STATUS\n").await;

    // ...but we *never* send a response, simulating a device timeout.
    // harness.send_response(b"STATUS_OK\n").unwrap(); // This line is omitted.

    // The client task should complete with a timeout error.
    let result = client_task.await.unwrap();
    assert!(result.is_err(), "Expected a timeout error");
}

#[tokio::test]
async fn test_multiple_commands() {
    let (port, mut harness) = mock_serial::new();
    let mut client = DeviceClient::new(port);

    let client_task = tokio::spawn(async move {
        let r1 = client.get_status().await.unwrap();
        // Imagine another command existed
        client.port.write_all(b"RESET\n").await.unwrap();
        let mut r2 = String::new();
        client.port.read_line(&mut r2).await.unwrap();
        (r1, r2)
    });

    // First interaction
    harness.expect_write(b"GET_STATUS\n").await;
    harness.send_response(b"STATUS_OK\n").unwrap();

    // Second interaction
    harness.expect_write(b"RESET\n").await;
    harness.send_response(b"RESET_ACK\n").unwrap();

    let (res1, res2) = client_task.await.unwrap();
    assert_eq!(res1, "STATUS_OK\n");
    assert_eq!(res2, "RESET_ACK\n");
}
```
</NEWFILE>
</GENERATED-CODE>
